{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home # This is the Zplugin wiki. The goal is to complement the README by providing a more easy to approach, more intuitively organized (with help of the MkDocs project-documentation tool) and also a more in-depth information.","title":"Home"},{"location":"#home","text":"This is the Zplugin wiki. The goal is to complement the README by providing a more easy to approach, more intuitively organized (with help of the MkDocs project-documentation tool) and also a more in-depth information.","title":"Home"},{"location":"Alternate-Ice-Syntax/","text":"Alternate Ice Syntax # The Standard Syntax # The normal way of specifying ices and their values is by concatenating the ice name and its value quoted, i.e.: zplugin wait\"1\" from\"gh-r\" atload\"print Hello World\" zplugin load \u2026 (note that there's no ice subcommand - that is currently being fully allowed) The Alternative Syntaxes # However, Zplugin supports also other syntaxes: the equal ( = ) syntax: zplugin wait=1 from=gh-r atload=\"print Hello World\" zplugin load \u2026 the colon ( : ) syntax: zplugin wait:1 from:gh-r atload:\"print Hello World\" zplugin load \u2026 and also \u2013 with conjunction with all of the above \u2013 the GNU syntax: zplugin --wait=1 --from=gh-r --atload=\"print Hello World\" zplugin load \u2026 Summary # It's up to the user which syntax to choose. The original motivation behind the standard syntax was: to utilize the syntax highlighting of editors like Vim \u2013 and have the strings following ice names colorized with a distinct color and this way separated from them. However, with the zplugin/zplugin-vim-syntax syntax definition this motivation can be superseded with the Zplugin-specific highlighting, at least for Vim. NOTE: the Vim syntax doesn't yet support the alternate syntaxes, it will soon (PR welcomed).","title":"Alternate Ice Syntax"},{"location":"Alternate-Ice-Syntax/#alternate_ice_syntax","text":"","title":"Alternate Ice Syntax"},{"location":"Alternate-Ice-Syntax/#the_standard_syntax","text":"The normal way of specifying ices and their values is by concatenating the ice name and its value quoted, i.e.: zplugin wait\"1\" from\"gh-r\" atload\"print Hello World\" zplugin load \u2026 (note that there's no ice subcommand - that is currently being fully allowed)","title":"The Standard Syntax"},{"location":"Alternate-Ice-Syntax/#the_alternative_syntaxes","text":"However, Zplugin supports also other syntaxes: the equal ( = ) syntax: zplugin wait=1 from=gh-r atload=\"print Hello World\" zplugin load \u2026 the colon ( : ) syntax: zplugin wait:1 from:gh-r atload:\"print Hello World\" zplugin load \u2026 and also \u2013 with conjunction with all of the above \u2013 the GNU syntax: zplugin --wait=1 --from=gh-r --atload=\"print Hello World\" zplugin load \u2026","title":"The Alternative Syntaxes"},{"location":"Alternate-Ice-Syntax/#summary","text":"It's up to the user which syntax to choose. The original motivation behind the standard syntax was: to utilize the syntax highlighting of editors like Vim \u2013 and have the strings following ice names colorized with a distinct color and this way separated from them. However, with the zplugin/zplugin-vim-syntax syntax definition this motivation can be superseded with the Zplugin-specific highlighting, at least for Vim. NOTE: the Vim syntax doesn't yet support the alternate syntaxes, it will soon (PR welcomed).","title":"Summary"},{"location":"Annexes/","text":"Annexes # What Are They? # They are Zplugin extensions. An annex is added to Zplugin by simply loading it just as any other plugin. What Can They Do? # Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand. How To Code Them? # Below is an example body of an atclone hook (taken from zplugin/z-a-submods annex). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a za- prefix, e.g. :za-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :za-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-annex : @zplg-register-annex \"myproject\" hook:atclone \\ :za-myproject-atclone-handler \\ :za-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-annex {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zplugin/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-a-* prefix is recommended for projects that are being annexes. Details # There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Annexes"},{"location":"Annexes/#annexes","text":"","title":"Annexes"},{"location":"Annexes/#what_are_they","text":"They are Zplugin extensions. An annex is added to Zplugin by simply loading it just as any other plugin.","title":"What Are They?"},{"location":"Annexes/#what_can_they_do","text":"Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand.","title":"What Can They Do?"},{"location":"Annexes/#how_to_code_them","text":"Below is an example body of an atclone hook (taken from zplugin/z-a-submods annex). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a za- prefix, e.g. :za-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :za-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-annex : @zplg-register-annex \"myproject\" hook:atclone \\ :za-myproject-atclone-handler \\ :za-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-annex {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zplugin/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-a-* prefix is recommended for projects that are being annexes.","title":"How To Code Them?"},{"location":"Annexes/#details","text":"There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Details"},{"location":"Code-Documentation/","text":"Code documentation # Here is code documentation generated using Zshelldoc . There are 4 Zplugin's source files, the main one is zplugin.zsh. The documentation lists all functions, interactions between them, their comments and features used. zplugin.zsh \u2013 always loaded, in .zshrc ( pdf ) zplugin-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zplugin-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zplugin-autoload.zsh \u2013 functions used only in interactive Zplugin invocations ( pdf )","title":"Overview"},{"location":"Code-Documentation/#code_documentation","text":"Here is code documentation generated using Zshelldoc . There are 4 Zplugin's source files, the main one is zplugin.zsh. The documentation lists all functions, interactions between them, their comments and features used. zplugin.zsh \u2013 always loaded, in .zshrc ( pdf ) zplugin-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zplugin-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zplugin-autoload.zsh \u2013 functions used only in interactive Zplugin invocations ( pdf )","title":"Code documentation"},{"location":"Compiling-programs/","text":"zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim as\"program\" \u2013 add file selected by pick'' to $PATH , do not source it, atclone\"\u2026\" \u2013 execute code after downloading, atpull\"%atclone\" \u2013 execute the same code atclone'' is given, but after successful update, make \u2013 run make after atclone'' and atpull'' (note: make'!' will execute before them), pick\"src/vim\" \u2013 set executable flag on src/vim , hint that src/ should be added to $PATH . The same but with installation (i.e. make install is being run) under $ZPFX ( ~/.zplugin/polaris by default): zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; \\ ./configure --prefix=$ZPFX\" atpull\"%atclone\" \\ make\"all install\" pick\"$ZPFX/bin/vim\" zplugin light vim/vim as\"program\" \u2013 as above, atclone\"\u2026\" \u2013 as above plus pass --prefix=$ZPFX to ./configure , to set the installation directory, atpull\"%atclone\" \u2013 as above, make \u2013 as above, but also run the install target, pick\"src/vim\" \u2013 as above, but for different path ( $ZPFX/bin/vim ). zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv make'!' \u2013 execute make before atclone'' and before atpull'' (see make above), src\"zhook.zsh\" \u2013 source file zhook.zsh . In general, Direnv works by hooking up to Zsh. The code that does this is provided by program direnv (built by make'' ). Above atclone'' puts this code into file zhook.zsh , src'' sources it. This way direnv hook zsh is executed only on clone and update, and Zsh starts faster.","title":"Compiling Programs"},{"location":"Direnv-explanation/","text":"The project direnv/direnv registers itself in Zshell to modify environment on directory change. This registration is most often done by eval \"$(direnv hook zsh)\" added to zshrc. Drawback of this standard procedure is that direnv binary is ran on every shell startup and significantly slows it down. Zplugin allows to solve this in following way: zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' pick\"direnv\" src\"zhook.zsh\" zplugin light direnv/direnv make'!' \u2013 compile direnv (it's written in Go lang); the exclamation mark means: run the make first, before atclone and atpull hooks, atclone'\u2026' \u2013 initially (right after installing the plugin) generate the registration code and save it to zhook.zsh (instead of passing to eval ), atpull'%atclone' \u2013 regenerate the registration code also on update ( atclone'' runs on installation while atpull runs on update of the plugin), src\"zhook.zsh\" \u2013 load ( source ) the generated registration code, pick\"direnv\" \u2013 ensure +x permission on the binary, as\"program\" \u2013 the plugin is a program, there's no main file to source. This way registration code is generated once every installation and update, to then be simply sourced without running direnv . The project is also available as binary Github release. This distribution can be installed by: zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" \\ './direnv hook zsh > zhook.zsh' atpull'%atclone' pick\"direnv\" zplugin light direnv/direnv from\"gh-r\" \u2013 install from Github releases , mv\"\u2026\" \u2013 after installation, rename direnv.linux-386 or similar file to direnv , atclone'\u2026' , atpull'\u2026' \u2013 as in previous example, pick\"direnv\" \u2013 as in previous example, as\"program\" \u2013 as in previous example.","title":"Direnv Explanation"},{"location":"Example-Minimal-Setup/","text":"Example Minimal Setup # zplugin ice wait blockf atpull'zplugin creinstall -q .' zplugin light zsh-users/zsh-completions zplugin ice wait atinit\"zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting zplugin ice wait atload\"_zsh_autosuggest_start\" zplugin light zsh-users/zsh-autosuggestions light \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zplugin report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are actually 0 , so in this mode you can load all plugins with the tracking, i.e. by using zplugin ice wait'0'; zplugin load {plugin-spec} commands, wait \u2013 load 0 seconds (about 5 ms exactly) after prompt, atpull'' \u2013 execute after updating the plugin \u2013 the command in the ice will install any new completions, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zpcompinit \u2013 equals to autoload compinit; compinit , zpcdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later (it provides the compdef function, so it must be ran before issuing compdef s), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) expect to be loaded last, even after the completion initialization (i.e. compinit function), hence the atinit'' , which will load compinit right before the plugin, however the true last-loaded plugin is the zsh-users/zsh-autosuggestions , because it runs a function in an precmd hook, i.e. right before first prompt, the atinit of the plugin runs also zpcdreplay (i.e. \" zplugin-compdef-replay \"), because after compinit is loaded, the compdef function becomes available, and one can re-run the all earlier automatically-caught compdef calls, loosing nothing from the original behavior, add lucid ice-mod to silence the under-prompt messages. The same setup but without using Turbo mode (i.e. no wait'' ice): zplugin ice blockf atpull'zplugin creinstall -q .' zplugin light zsh-users/zsh-completions autoload compinit compinit zplugin light zdharma/fast-syntax-highlighting zplugin light zsh-users/zsh-autosuggestions","title":"Example Minimal Setup"},{"location":"Example-Minimal-Setup/#example_minimal_setup","text":"zplugin ice wait blockf atpull'zplugin creinstall -q .' zplugin light zsh-users/zsh-completions zplugin ice wait atinit\"zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting zplugin ice wait atload\"_zsh_autosuggest_start\" zplugin light zsh-users/zsh-autosuggestions light \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zplugin report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are actually 0 , so in this mode you can load all plugins with the tracking, i.e. by using zplugin ice wait'0'; zplugin load {plugin-spec} commands, wait \u2013 load 0 seconds (about 5 ms exactly) after prompt, atpull'' \u2013 execute after updating the plugin \u2013 the command in the ice will install any new completions, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zpcompinit \u2013 equals to autoload compinit; compinit , zpcdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later (it provides the compdef function, so it must be ran before issuing compdef s), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) expect to be loaded last, even after the completion initialization (i.e. compinit function), hence the atinit'' , which will load compinit right before the plugin, however the true last-loaded plugin is the zsh-users/zsh-autosuggestions , because it runs a function in an precmd hook, i.e. right before first prompt, the atinit of the plugin runs also zpcdreplay (i.e. \" zplugin-compdef-replay \"), because after compinit is loaded, the compdef function becomes available, and one can re-run the all earlier automatically-caught compdef calls, loosing nothing from the original behavior, add lucid ice-mod to silence the under-prompt messages. The same setup but without using Turbo mode (i.e. no wait'' ice): zplugin ice blockf atpull'zplugin creinstall -q .' zplugin light zsh-users/zsh-completions autoload compinit compinit zplugin light zdharma/fast-syntax-highlighting zplugin light zsh-users/zsh-autosuggestions","title":"Example Minimal Setup"},{"location":"Example-Oh-My-Zsh-setup/","text":"# A. setopt promptsubst # B. zplugin ice wait lucid zplugin snippet OMZ::lib/git.zsh # C. zplugin ice wait atload\"unalias grv\" lucid zplugin snippet OMZ::plugins/git/git.plugin.zsh # D. PS1=\"READY >\" # provide a nice prompt till the theme loads zplugin ice wait'!' lucid zplugin snippet OMZ::themes/dstufft.zsh-theme # E. zplugin ice wait lucid zplugin snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh # F. zplugin ice wait as\"completion\" lucid zplugin snippet OMZ::plugins/docker/_docker # G. zplugin ice wait atinit\"zpcompinit\" lucid zplugin light zdharma/fast-syntax-highlighting A - Most themes use this option. B - OMZ themes use this library. C - Some OMZ themes use this plugin. It provides many aliases \u2013 atload'' shows how to disable some of them (to use program rgburke/grv ). D - Set OMZ theme. E - Example functional plugin. F - Load Docker completion. G - Normal plugin (syntax-highlighting, at the end, like it is suggested by the plugin's README). Completions provided by git plugin are catched, but ignored. They can be executed using function zpcdreplay appended after zpcompinit; in atinit'' of G . Above setup loads everything after prompt, because of preceding wait ice. That is called Turbo mode , it shortens Zsh startup time by 50%-73% , so e.g. instead of 200 ms, you'll be getting your shell started up after 50 ms (!). The same setup without Turbo mode (prompt will be initially set like in typical, normal setup \u2013 you can remove wait only from the theme plugin to have the same effect while still using Turbo mode for everything remaining): # A. setopt promptsubst # B. zplugin snippet OMZ::lib/git.zsh # C. zplugin ice atload\"unalias grv\" zplugin snippet OMZ::plugins/git/git.plugin.zsh # D. zplugin snippet OMZ::themes/dstufft.zsh-theme # E. zplugin snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh # F. zplugin ice as\"completion\" zplugin snippet OMZ::plugins/docker/_docker # G. zplugin ice atinit\"zpcompinit\" zplugin light zdharma/fast-syntax-highlighting In general, Turbo mode can be optionally enabled only for a subset of plugins or for all plugins. It needs Zsh >= 5.3. The Introduction contains more information on Turbo mode.","title":"Example Oh My Zsh Setup"},{"location":"Example-wait-conditions/","text":"Note Turbo mode, i.e. the wait ice that implements it needs Zsh >= 5.3. zplugin ice wait'0' # or just: zplugin ice wait zplugin light wfxr/forgit waits for prompt, instantly (\"0\" seconds) after prompt loads given plugin. zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cras*]} ]]' zplugin light zdharma/zplugin-crasis $ZLAST_COMMANDS is an array build by fast-syntax-highlighting , it contains commands currently entered at prompt, (r) searches for element that matches given pattern ( cras* ) and returns it, -n means: not-empty, so it will be true when users enters \"cras\", after 1 second or less, Zplugin will detect that wait'' condition is true, and load the plugin, which provides command crasis , Screencast that presents the feature: zplugin ice wait'[[ $PWD = */github || $PWD = */github/* ]]' zplugin load unixorn/git-extra-commands waits until user enters a github directory. Turbo mode also support a suffix \u2013 the letter a , b or c . The meaning is illustrated by the following example: zplugin ice wait\"0b\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 1\" lucid zplugin light mfaerevaag/wd zplugin ice wait\"0a\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 2\" lucid zplugin light mfaerevaag/wd # The output Firing 2 Firing 1 As it can be seen, the second plugin has been loaded first. That's because there are now three sub-slots (the a , b and c ) in which the plugin/snippet loadings can be put into. Plugins from the same time-slot with suffix a will be loaded before plugins with suffix b , etc. In other words, instead of wait'1' you can enter wait'1a' , wait'1b' and wait'1c' \u2013 to this way impose order on the loadings regardless of the order of zplugin commands .","title":"Example wait Conditions"},{"location":"For-Syntax/","text":"The For-Syntax # Introduction # The Introduction covers the classic Zplugin invocation syntax, which is: zplugin ice \u2026 zplugin load \u2026 # or zplugin light, zplugin snippet It is a fundamental Zplugin syntax. However, a more concise, optimized syntax, called for-syntax , is also available. It is best presented by a real-world example: zplugin as\"null\" wait\"3\" lucid for \\ sbin Fakerr/git-recall \\ sbin paulirish/git-open \\ sbin paulirish/git-recent \\ sbin davidosomething/git-my \\ make\"PREFIX=$ZPFX install\" iwata/git-now \\ make\"PREFIX=$ZPFX\" tj/git-extras Above single command installs 6 plugins (Git extension-packages), with the base ices as\"null\" wait\"3\" lucid that are common to all of the plugins and 6 plugin-specific add-on ices. A Few Remarks # The syntax automatically detects if the object is a snippet or a plugin, by checking if the object is an URL, i.e.: if it starts with http*:// or OMZ:: , etc. To load a local-file snippet (which will be treaten as a local-directory plugin by default) use the is-snippet ice, To load a plugin in light mode use the light-mode ice. If the plugin name collides with an ice name, precede the plugin name with @ , e.g.: @sharkdp/fd (collides with the sh ice, Zplugin will take the plugin name as sh\"arkdp/fd\" ), see the next section for an example. Examples # Load a few useful binary (i.e.: binary packages from the GitHub Releases) utils: zplugin as\"null\" wait\"2\" lucid from\"gh-r\" for \\ mv\"exa* -> exa\" sbin ogham/exa \\ mv\"fd* -> fd\" sbin\"fd/fd\" @sharkdp/fd \\ sbin\"fzf\" junegunn/fzf-bin Note: sbin'' is an ice added by the z-a-bin-gem-node annex, it provides the command to the command line without altering $PATH . If the name of the command is the same as the name of the plugin, the ice contents can be skipped. Turbo load some plugins, without any plugin-specific ices: zplugin wait lucid for \\ hlissner/zsh-autopair \\ urbainvaes/fzf-marks Load two Oh My Zsh files as snippets, in Turbo: zplugin wait lucid for \\ OMZ::lib/git.zsh \\ atload\"unalias grv\" OMZ::plugins/git/git.plugin.zsh","title":"The For Syntax"},{"location":"For-Syntax/#the_for-syntax","text":"","title":"The For-Syntax"},{"location":"For-Syntax/#introduction","text":"The Introduction covers the classic Zplugin invocation syntax, which is: zplugin ice \u2026 zplugin load \u2026 # or zplugin light, zplugin snippet It is a fundamental Zplugin syntax. However, a more concise, optimized syntax, called for-syntax , is also available. It is best presented by a real-world example: zplugin as\"null\" wait\"3\" lucid for \\ sbin Fakerr/git-recall \\ sbin paulirish/git-open \\ sbin paulirish/git-recent \\ sbin davidosomething/git-my \\ make\"PREFIX=$ZPFX install\" iwata/git-now \\ make\"PREFIX=$ZPFX\" tj/git-extras Above single command installs 6 plugins (Git extension-packages), with the base ices as\"null\" wait\"3\" lucid that are common to all of the plugins and 6 plugin-specific add-on ices.","title":"Introduction"},{"location":"For-Syntax/#a_few_remarks","text":"The syntax automatically detects if the object is a snippet or a plugin, by checking if the object is an URL, i.e.: if it starts with http*:// or OMZ:: , etc. To load a local-file snippet (which will be treaten as a local-directory plugin by default) use the is-snippet ice, To load a plugin in light mode use the light-mode ice. If the plugin name collides with an ice name, precede the plugin name with @ , e.g.: @sharkdp/fd (collides with the sh ice, Zplugin will take the plugin name as sh\"arkdp/fd\" ), see the next section for an example.","title":"A Few Remarks"},{"location":"For-Syntax/#examples","text":"Load a few useful binary (i.e.: binary packages from the GitHub Releases) utils: zplugin as\"null\" wait\"2\" lucid from\"gh-r\" for \\ mv\"exa* -> exa\" sbin ogham/exa \\ mv\"fd* -> fd\" sbin\"fd/fd\" @sharkdp/fd \\ sbin\"fzf\" junegunn/fzf-bin Note: sbin'' is an ice added by the z-a-bin-gem-node annex, it provides the command to the command line without altering $PATH . If the name of the command is the same as the name of the plugin, the ice contents can be skipped. Turbo load some plugins, without any plugin-specific ices: zplugin wait lucid for \\ hlissner/zsh-autopair \\ urbainvaes/fzf-marks Load two Oh My Zsh files as snippets, in Turbo: zplugin wait lucid for \\ OMZ::lib/git.zsh \\ atload\"unalias grv\" OMZ::plugins/git/git.plugin.zsh","title":"Examples"},{"location":"GALLERY/","text":"Gallery Of Zplugin Invocations # PRs welcomed :) Programs # zplugin ice from\"gh-r\" as\"program\" zplugin light junegunn/fzf-bin # sharkdp/fd zplugin ice as\"command\" from\"gh-r\" mv\"fd* -> fd\" pick\"fd/fd\" zplugin light sharkdp/fd # sharkdp/bat zplugin ice as\"command\" from\"gh-r\" mv\"bat* -> bat\" pick\"bat/bat\" zplugin light sharkdp/bat # ogham/exa, replacement for ls zplugin ice wait\"2\" lucid from\"gh-r\" as\"program\" mv\"exa* -> exa\" zplugin light ogham/exa zplugin ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zplugin light docker/compose zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zplugin light mvdan/sh zplugin ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zplugin light b4b4r07/gotcha zplugin ice as\"program\" pick\"yank\" make zplugin light mptre/yank zplugin ice wait\"2\" lucid as'command' pick'src/vramsteg' \\ atclone'cmake .' atpull'%atclone' make # use Turbo mode zplugin light psprint/vramsteg-zsh zplugin ice atclone'PYENV_ROOT=\"$PWD\" ./libexec/pyenv init - > zpyenv.zsh' \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zplugin light pyenv/pyenv zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null # asciinema zplugin ice as\"command\" wait lucid \\ atinit\"export PYTHONPATH=$ZPFX/lib/python3.7/site-packages/\" \\ atclone\"PYTHONPATH=$ZPFX/lib/python3.7/site-packages/ \\ python3 setup.py --quiet install --prefix $ZPFX\" \\ atpull'%atclone' test'0' \\ pick\"$ZPFX/bin/asciinema\" zplugin load asciinema/asciinema.git Completions # zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Scripts # # ogham/exa also uses the definitions zplugin ice wait\"0c\" lucid reset \\ atclone\"local P=${${(M)OSTYPE:#*darwin*}:+g} \\${P}sed -i \\ '/DIR/c\\DIR 38;5;63;1' LS_COLORS; \\ \\${P}dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zplugin light trapd00r/LS_COLORS # revolver zplugin ice wait\"2\" lucid as\"program\" pick\"revolver\" zplugin light molovo/revolver # zunit zplugin ice wait\"2\" lucid as\"program\" pick\"zunit\" \\ atclone\"./build.zsh\" atpull\"%atclone\" zplugin load molovo/zunit zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zplugin light tj/git-extras zplugin ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zplugin light k4rthik/git-cal zplugin ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique zplugin ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zplugin light mfaerevaag/wd zplugin ice as\"program\" pick\"bin/archey\" zplugin load obihann/archey-osx Plugins # zplugin ice pick\"h.sh\" zplugin light paoloantinori/hhighlighter # zsh-tag-search; after ^G, prepend with \"/\" for the regular search zplugin ice wait lucid bindmap\"^R -> ^G\" zplugin light -b zdharma/zsh-tag-search # forgit zplugin ice wait lucid zplugin load 'wfxr/forgit' # diff-so-fancy zplugin ice wait\"2\" lucid as\"program\" pick\"bin/git-dsf\" zplugin load zdharma/zsh-diff-so-fancy # zsh-startify, a vim-startify like plugin zplugin ice wait\"0b\" lucid atload\"zsh-startify\" zplugin load zdharma/zsh-startify # declare-zsh zplugin ice wait\"2\" lucid zplugin load zdharma/declare-zsh # fzf-marks zplugin ice wait lucid zplugin load urbainvaes/fzf-marks # zsh-autopair zplugin ice wait lucid zplugin load hlissner/zsh-autopair zplugin ice wait\"1\" lucid zplugin load psprint/zsh-navigation-tools # zdharma/history-search-multi-word zstyle \":history-search-multi-word\" page-size \"11\" zplugin ice wait\"1\" lucid zplugin load zdharma/history-search-multi-word # ZUI and Crasis zplugin ice wait\"1\" lucid zplugin load zdharma/zui zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cra*]} ]]' lucid zplugin load zdharma/zplugin-crasis # Gitignore plugin \u2013 commands gii and gi zplugin ice wait\"2\" lucid zplugin load voronkovich/gitignore.plugin.zsh # Autosuggestions & fast-syntax-highlighting zplugin ice wait\"1\" lucid atinit\"ZPLGM[COMPINIT_OPTS]=-C; zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting # zsh-autosuggestions zplugin ice wait\"1\" lucid atload\"!_zsh_autosuggest_start\" zplugin load zsh-users/zsh-autosuggestions # F-Sy-H automatic themes plugin \u2013 available for patrons: # https://patreon.com/psprint zplugin ice wait\"1\" lucid from\"psprint@gitlab.com\" zplugin load psprint/fsh-auto-themes # zredis together with some binding/tying # \u2013 defines the variable $rdhash zstyle \":plugin:zredis\" configure_opts \"--without-tcsetpgrp\" zstyle \":plugin:zredis\" cflags \"-Wall -O2 -g -Wno-unused-but-set-variable\" zplugin ice wait\"1\" lucid \\ atload'ztie -d db/redis -a 127.0.0.1:4815/5 -zSL main rdhash' zplugin load zdharma/zredis # Github-Issue-Tracker \u2013 the notifier thread zplugin ice lucid id-as\"GitHub-notify\" \\ on-update-of'~/.cache/zsh-github-issues/new_titles.log' \\ notify'New issue: $NOTIFY_MESSAGE' zplugin light zdharma/zsh-github-issues Services # # a service that runs the redis database, in background, single instance zplugin ice wait\"1\" lucid service\"redis\" zplugin light zservices/redis # Github-Issue-Tracker \u2013 the issue-puller thread GIT_SLEEP_TIME=700 GIT_PROJECTS=zdharma/zsh-github-issues:zdharma/zplugin zplugin ice wait\"2\" lucid service\"GIT\" pick\"zsh-github-issues.service.zsh\" zplugin light zdharma/zsh-github-issues Snippets # zplugin ice svn pick\"completion.zsh\" src\"git.zsh\" zplugin snippet OMZ::lib zplugin ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zplugin snippet OMZ::plugins/osx # Or with most recent Zplugin and with ~/.zplugin/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zplugin ice svn zplugin snippet OMZ::plugins/osx Themes # GEOMETRY_COLOR_DIR=152 zplugin ice wait\"0\" lucid atload\"geometry::prompt\" zplugin light geometry-zsh/geometry zplugin ice pick\"async.zsh\" src\"pure.zsh\" zplugin light sindresorhus/pure zplugin light mafredri/zsh-async # dependency zplugin ice svn silent atload'prompt sorin' zplugin snippet PZT::modules/prompt zplugin ice atload\"fpath+=( \\$PWD );\" zplugin light chauncey-garrett/zsh-prompt-garrett zplugin ice svn atload\"prompt garrett\" silent zplugin snippet PZT::modules/prompt zplugin ice wait'!' lucid nocompletions \\ compile\"{zinc_functions/*,segments/*,zinc.zsh}\" \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zplugin load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zplugin ice wait'1' atload'zinc_optional_depenency_loaded' zplugin load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zplugin ice wait'!' lucid atload'true; _p9k_precmd' nocd zplugin light romkatv/powerlevel10k","title":"Gallery"},{"location":"GALLERY/#gallery_of_zplugin_invocations","text":"PRs welcomed :)","title":"Gallery Of Zplugin Invocations"},{"location":"GALLERY/#programs","text":"zplugin ice from\"gh-r\" as\"program\" zplugin light junegunn/fzf-bin # sharkdp/fd zplugin ice as\"command\" from\"gh-r\" mv\"fd* -> fd\" pick\"fd/fd\" zplugin light sharkdp/fd # sharkdp/bat zplugin ice as\"command\" from\"gh-r\" mv\"bat* -> bat\" pick\"bat/bat\" zplugin light sharkdp/bat # ogham/exa, replacement for ls zplugin ice wait\"2\" lucid from\"gh-r\" as\"program\" mv\"exa* -> exa\" zplugin light ogham/exa zplugin ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zplugin light docker/compose zplugin ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zplugin light vim/vim zplugin ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zplugin light direnv/direnv zplugin ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zplugin light mvdan/sh zplugin ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zplugin light b4b4r07/gotcha zplugin ice as\"program\" pick\"yank\" make zplugin light mptre/yank zplugin ice wait\"2\" lucid as'command' pick'src/vramsteg' \\ atclone'cmake .' atpull'%atclone' make # use Turbo mode zplugin light psprint/vramsteg-zsh zplugin ice atclone'PYENV_ROOT=\"$PWD\" ./libexec/pyenv init - > zpyenv.zsh' \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zplugin light pyenv/pyenv zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null # asciinema zplugin ice as\"command\" wait lucid \\ atinit\"export PYTHONPATH=$ZPFX/lib/python3.7/site-packages/\" \\ atclone\"PYTHONPATH=$ZPFX/lib/python3.7/site-packages/ \\ python3 setup.py --quiet install --prefix $ZPFX\" \\ atpull'%atclone' test'0' \\ pick\"$ZPFX/bin/asciinema\" zplugin load asciinema/asciinema.git","title":"Programs"},{"location":"GALLERY/#completions","text":"zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Completions"},{"location":"GALLERY/#scripts","text":"# ogham/exa also uses the definitions zplugin ice wait\"0c\" lucid reset \\ atclone\"local P=${${(M)OSTYPE:#*darwin*}:+g} \\${P}sed -i \\ '/DIR/c\\DIR 38;5;63;1' LS_COLORS; \\ \\${P}dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zplugin light trapd00r/LS_COLORS # revolver zplugin ice wait\"2\" lucid as\"program\" pick\"revolver\" zplugin light molovo/revolver # zunit zplugin ice wait\"2\" lucid as\"program\" pick\"zunit\" \\ atclone\"./build.zsh\" atpull\"%atclone\" zplugin load molovo/zunit zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zplugin light tj/git-extras zplugin ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zplugin light k4rthik/git-cal zplugin ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique zplugin ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zplugin light mfaerevaag/wd zplugin ice as\"program\" pick\"bin/archey\" zplugin load obihann/archey-osx","title":"Scripts"},{"location":"GALLERY/#plugins","text":"zplugin ice pick\"h.sh\" zplugin light paoloantinori/hhighlighter # zsh-tag-search; after ^G, prepend with \"/\" for the regular search zplugin ice wait lucid bindmap\"^R -> ^G\" zplugin light -b zdharma/zsh-tag-search # forgit zplugin ice wait lucid zplugin load 'wfxr/forgit' # diff-so-fancy zplugin ice wait\"2\" lucid as\"program\" pick\"bin/git-dsf\" zplugin load zdharma/zsh-diff-so-fancy # zsh-startify, a vim-startify like plugin zplugin ice wait\"0b\" lucid atload\"zsh-startify\" zplugin load zdharma/zsh-startify # declare-zsh zplugin ice wait\"2\" lucid zplugin load zdharma/declare-zsh # fzf-marks zplugin ice wait lucid zplugin load urbainvaes/fzf-marks # zsh-autopair zplugin ice wait lucid zplugin load hlissner/zsh-autopair zplugin ice wait\"1\" lucid zplugin load psprint/zsh-navigation-tools # zdharma/history-search-multi-word zstyle \":history-search-multi-word\" page-size \"11\" zplugin ice wait\"1\" lucid zplugin load zdharma/history-search-multi-word # ZUI and Crasis zplugin ice wait\"1\" lucid zplugin load zdharma/zui zplugin ice wait'[[ -n ${ZLAST_COMMANDS[(r)cra*]} ]]' lucid zplugin load zdharma/zplugin-crasis # Gitignore plugin \u2013 commands gii and gi zplugin ice wait\"2\" lucid zplugin load voronkovich/gitignore.plugin.zsh # Autosuggestions & fast-syntax-highlighting zplugin ice wait\"1\" lucid atinit\"ZPLGM[COMPINIT_OPTS]=-C; zpcompinit; zpcdreplay\" zplugin light zdharma/fast-syntax-highlighting # zsh-autosuggestions zplugin ice wait\"1\" lucid atload\"!_zsh_autosuggest_start\" zplugin load zsh-users/zsh-autosuggestions # F-Sy-H automatic themes plugin \u2013 available for patrons: # https://patreon.com/psprint zplugin ice wait\"1\" lucid from\"psprint@gitlab.com\" zplugin load psprint/fsh-auto-themes # zredis together with some binding/tying # \u2013 defines the variable $rdhash zstyle \":plugin:zredis\" configure_opts \"--without-tcsetpgrp\" zstyle \":plugin:zredis\" cflags \"-Wall -O2 -g -Wno-unused-but-set-variable\" zplugin ice wait\"1\" lucid \\ atload'ztie -d db/redis -a 127.0.0.1:4815/5 -zSL main rdhash' zplugin load zdharma/zredis # Github-Issue-Tracker \u2013 the notifier thread zplugin ice lucid id-as\"GitHub-notify\" \\ on-update-of'~/.cache/zsh-github-issues/new_titles.log' \\ notify'New issue: $NOTIFY_MESSAGE' zplugin light zdharma/zsh-github-issues","title":"Plugins"},{"location":"GALLERY/#services","text":"# a service that runs the redis database, in background, single instance zplugin ice wait\"1\" lucid service\"redis\" zplugin light zservices/redis # Github-Issue-Tracker \u2013 the issue-puller thread GIT_SLEEP_TIME=700 GIT_PROJECTS=zdharma/zsh-github-issues:zdharma/zplugin zplugin ice wait\"2\" lucid service\"GIT\" pick\"zsh-github-issues.service.zsh\" zplugin light zdharma/zsh-github-issues","title":"Services"},{"location":"GALLERY/#snippets","text":"zplugin ice svn pick\"completion.zsh\" src\"git.zsh\" zplugin snippet OMZ::lib zplugin ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zplugin snippet OMZ::plugins/osx # Or with most recent Zplugin and with ~/.zplugin/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zplugin ice svn zplugin snippet OMZ::plugins/osx","title":"Snippets"},{"location":"GALLERY/#themes","text":"GEOMETRY_COLOR_DIR=152 zplugin ice wait\"0\" lucid atload\"geometry::prompt\" zplugin light geometry-zsh/geometry zplugin ice pick\"async.zsh\" src\"pure.zsh\" zplugin light sindresorhus/pure zplugin light mafredri/zsh-async # dependency zplugin ice svn silent atload'prompt sorin' zplugin snippet PZT::modules/prompt zplugin ice atload\"fpath+=( \\$PWD );\" zplugin light chauncey-garrett/zsh-prompt-garrett zplugin ice svn atload\"prompt garrett\" silent zplugin snippet PZT::modules/prompt zplugin ice wait'!' lucid nocompletions \\ compile\"{zinc_functions/*,segments/*,zinc.zsh}\" \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zplugin load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zplugin ice wait'1' atload'zinc_optional_depenency_loaded' zplugin load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zplugin ice wait'!' lucid atload'true; _p9k_precmd' nocd zplugin light romkatv/powerlevel10k","title":"Themes"},{"location":"INTRODUCTION/","text":"Introduction # In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more. Basic Plugin Loading # zplugin load zdharma/history-search-multi-word zplugin light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zplugin report {plugin-spec} and then also unload the plugin with zplugin unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible. Oh My Zsh, Prezto # To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zplugin snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zplugin snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zplugin snippet OMZ::plugins/git/git.plugin.zsh zplugin snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zplugin ice svn zplugin snippet PZT::modules/docker Snippets and Performance # Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zplugin , it is really fast and also compact (causing low memory footprint and short loading time). Some Ice-Modifiers # The command zplugin ice provides Ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zplugin sense this means that ice is a modifier added to the next Zplugin command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zplugin use it means that the modifier lasts for only single next Zplugin command. Using one other Ice-modifier \" pick \" user can explicitly select the file to source : zplugin ice svn pick\"init.zsh\" zplugin snippet PZT::modules/git Content of Ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after Ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and zdharma/fast-syntax-highlighting will highlight contents of Ice-modifiers. as\"program\" # A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use Ice-modifier as with value program (or an alias value command ). zplugin ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zplugin light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other Ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zplugin delete PZT::modules/osx (for example). atpull\"\u2026\" # Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an Ice\u2013modifier ran at update of plugin) will be used: zplugin ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zplugin light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zplugin update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull Ice-mod. Snippets-Commands # Commands can also be added to $PATH using snippets . For example: zplugin ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zplugin snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull Ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit Ice-mod, executed before each loading of plugin or snippet. Snippets-Completions # By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Completion Management # Zplugin allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zplugin ice blockf zplugin light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zplugin uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zplugin will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zplugin cuninstall zsh-users/zsh-completions # uninstall zplugin creinstall zsh-users/zsh-completions # install Listing Completions # Note zplg is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zplg clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zplg clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ... Enabling and Disabling Completions # Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zplg cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zplg cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zplugin csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions. Subversion for Subdirectories # In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zplugin ice svn zplugin snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zplugin ice svn; zplugin snippet PZT::modules/docker Snippets too have completions installed by default, like plugins. Turbo Mode (Zsh >= 5.3) # The Ice-mod wait allows you to postpone loading of a plugin to the moment when processing of .zshrc is finished and prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zplugin, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for number of such plugins like 10 or 20 . Note Turbo mode will speed up Zsh startup by 50%\u201373% . For example instead of 200 ms, it'll be 50 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zplugin ice wait'!0' zplugin load halfo/lambda-mod-zsh-theme This sets plugin psprint/zprompts to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . I\u2019ve started to use this method of setting up a prompt 2 years ago now and I run it without any problems. It is also sufficient to provide just the word wait , it\u2019ll work like wait'0' (and wait'!' like wait'!0' ). The exclamation mark causes Zplugin to reset-prompt after loading plugin, so it is needed for themes. The same with Prezto prompts, with a longer delay: zplg ice svn silent wait'!1' atload'prompt smiley' zplg snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zplugin ice wait lucid atload'_zsh_autosuggest_start' zplugin light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc (right before the first prompt). Turbo mode will wait 1 second after that, so precmd will not be installed and thus not called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload Ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. The ice lucid causes the under-prompt message saying Loaded zsh-users/zsh-autosuggestions that normally appears for every Turbo-loaded plugin to not show. Turbo-Loading Sophisticated Prompts # For some, mostly advanced themes the initialization of the prompt is being done in a precmd -hook, i.e.; in a function that's gets called before each prompt. The hook is installed by the add-zsh-hook Zsh function by adding its name to the $precmd_functions array. To make the prompt fully initialized after Turbo loading in the middle of the prompt (the same situation as with the zsh-autosuggestions plugin), the hook should be called from atload'' ice. First, find the name of the hook function by examining the $precmd_functions array. For example, for robobenklein/zinc theme, they'll be two functions: prompt_zinc_setup and prompt_zinc_precmd : root@sg > ~ > print $precmd_functions < \u2714 < 22:21:33 _zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd Then, add them to the ice-list in the atload'' ice: zplugin ice wait'!' lucid nocd \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zplugin load robobenklein/zinc The exclamation mark in atload'!\u2026' is to track the functions allowing the plugin to be unloaded, as described here . It might be useful for the multi-prompt setup described next. Automatic Load/Unload on Condition # Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zplugin ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"!promptinit; prompt sprint3\" zplugin load psprint/zprompts # Load when NOT in ~/tmp zplugin ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zplugin load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zplugin load \u2026 , not zplugin light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts . It contains a more real-world examples of a multi-prompt setup, which is being close to what the author uses in own setup.","title":"Introduction"},{"location":"INTRODUCTION/#introduction","text":"In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more.","title":"Introduction"},{"location":"INTRODUCTION/#basic_plugin_loading","text":"zplugin load zdharma/history-search-multi-word zplugin light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zplugin report {plugin-spec} and then also unload the plugin with zplugin unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible.","title":"Basic Plugin Loading"},{"location":"INTRODUCTION/#oh_my_zsh_prezto","text":"To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zplugin snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zplugin snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zplugin snippet OMZ::plugins/git/git.plugin.zsh zplugin snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zplugin ice svn zplugin snippet PZT::modules/docker","title":"Oh My Zsh, Prezto"},{"location":"INTRODUCTION/#snippets_and_performance","text":"Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zplugin , it is really fast and also compact (causing low memory footprint and short loading time).","title":"Snippets and Performance"},{"location":"INTRODUCTION/#some_ice-modifiers","text":"The command zplugin ice provides Ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zplugin sense this means that ice is a modifier added to the next Zplugin command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zplugin use it means that the modifier lasts for only single next Zplugin command. Using one other Ice-modifier \" pick \" user can explicitly select the file to source : zplugin ice svn pick\"init.zsh\" zplugin snippet PZT::modules/git Content of Ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after Ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and zdharma/fast-syntax-highlighting will highlight contents of Ice-modifiers.","title":"Some Ice-Modifiers"},{"location":"INTRODUCTION/#asprogram","text":"A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use Ice-modifier as with value program (or an alias value command ). zplugin ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zplugin light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other Ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zplugin delete PZT::modules/osx (for example).","title":"as\"program\""},{"location":"INTRODUCTION/#atpull","text":"Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an Ice\u2013modifier ran at update of plugin) will be used: zplugin ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zplugin light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zplugin update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull Ice-mod.","title":"atpull\"\u2026\""},{"location":"INTRODUCTION/#snippets-commands","text":"Commands can also be added to $PATH using snippets . For example: zplugin ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zplugin snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull Ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit Ice-mod, executed before each loading of plugin or snippet.","title":"Snippets-Commands"},{"location":"INTRODUCTION/#snippets-completions","text":"By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zplugin ice as\"completion\" zplugin snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Snippets-Completions"},{"location":"INTRODUCTION/#completion_management","text":"Zplugin allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zplugin ice blockf zplugin light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zplugin uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zplugin will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zplugin cuninstall zsh-users/zsh-completions # uninstall zplugin creinstall zsh-users/zsh-completions # install","title":"Completion Management"},{"location":"INTRODUCTION/#listing_completions","text":"Note zplg is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zplg clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zplg clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ...","title":"Listing Completions"},{"location":"INTRODUCTION/#enabling_and_disabling_completions","text":"Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zplg cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zplg cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zplugin csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions.","title":"Enabling and Disabling Completions"},{"location":"INTRODUCTION/#subversion_for_subdirectories","text":"In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zplugin ice svn zplugin snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zplugin ice svn; zplugin snippet PZT::modules/docker Snippets too have completions installed by default, like plugins.","title":"Subversion for Subdirectories"},{"location":"INTRODUCTION/#turbo_mode_zsh_62_53","text":"The Ice-mod wait allows you to postpone loading of a plugin to the moment when processing of .zshrc is finished and prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zplugin, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for number of such plugins like 10 or 20 . Note Turbo mode will speed up Zsh startup by 50%\u201373% . For example instead of 200 ms, it'll be 50 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zplugin ice wait'!0' zplugin load halfo/lambda-mod-zsh-theme This sets plugin psprint/zprompts to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . I\u2019ve started to use this method of setting up a prompt 2 years ago now and I run it without any problems. It is also sufficient to provide just the word wait , it\u2019ll work like wait'0' (and wait'!' like wait'!0' ). The exclamation mark causes Zplugin to reset-prompt after loading plugin, so it is needed for themes. The same with Prezto prompts, with a longer delay: zplg ice svn silent wait'!1' atload'prompt smiley' zplg snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zplugin ice wait lucid atload'_zsh_autosuggest_start' zplugin light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc (right before the first prompt). Turbo mode will wait 1 second after that, so precmd will not be installed and thus not called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload Ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. The ice lucid causes the under-prompt message saying Loaded zsh-users/zsh-autosuggestions that normally appears for every Turbo-loaded plugin to not show.","title":"Turbo Mode (Zsh >= 5.3)"},{"location":"INTRODUCTION/#turbo-loading_sophisticated_prompts","text":"For some, mostly advanced themes the initialization of the prompt is being done in a precmd -hook, i.e.; in a function that's gets called before each prompt. The hook is installed by the add-zsh-hook Zsh function by adding its name to the $precmd_functions array. To make the prompt fully initialized after Turbo loading in the middle of the prompt (the same situation as with the zsh-autosuggestions plugin), the hook should be called from atload'' ice. First, find the name of the hook function by examining the $precmd_functions array. For example, for robobenklein/zinc theme, they'll be two functions: prompt_zinc_setup and prompt_zinc_precmd : root@sg > ~ > print $precmd_functions < \u2714 < 22:21:33 _zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd Then, add them to the ice-list in the atload'' ice: zplugin ice wait'!' lucid nocd \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zplugin load robobenklein/zinc The exclamation mark in atload'!\u2026' is to track the functions allowing the plugin to be unloaded, as described here . It might be useful for the multi-prompt setup described next.","title":"Turbo-Loading Sophisticated Prompts"},{"location":"INTRODUCTION/#automatic_loadunload_on_condition","text":"Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zplugin ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"!promptinit; prompt sprint3\" zplugin load psprint/zprompts # Load when NOT in ~/tmp zplugin ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zplugin load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zplugin load \u2026 , not zplugin light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts . It contains a more real-world examples of a multi-prompt setup, which is being close to what the author uses in own setup.","title":"Automatic Load/Unload on Condition"},{"location":"Installing-with-make/","text":"zplugin ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" zplugin light tj/git-extras Makefile of this project has only one needed target \u2013 install , which is called by default, it also does building of the scripts that it installs, so it does 2 tasks, for Makefile with 2 targets, one could use make\"all install PREFIX=\u2026\" , pick'\u2026' will chmod +x all matching files and add $ZPFX/bin/ to $PATH , $ZPFX is provided by Zplugin, it is ~/.zplugin/polaris by default, can be also customized. Below is a hard core but fully working method of managing a software ( sdkman.io ) with Zplugin. # The invocation uses https://github.com/zdharma/null repo as a placeholder # for the atclone'' and atpull'' hooks zplugin ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zplugin light zdharma/null","title":"Installing With Make"},{"location":"LS_COLORS-explanation/","text":"A repository trapd00r/LS_COLORS provides a file with color definitions for GNU ls command (and also for ogham/exa ; it can be also used to style Zsh completion \u2013 more on this below). Typically one does eval $( dircolors -b $HOME/LS_COLORS) to process this file and set environment for ls . However this means dircolors is ran every shell startup. This costs much time, because a fork has to be done and the program (i.e. dircolors ) binary needs to be loaded and executed, and because dircolors loads the colors' definitions and processes them. Following Zplugin invocation solves this problem: zplugin ice atclone\"dircolors -b LS_COLORS > clrs.zsh\" \\ atpull'%atclone' pick\"clrs.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zplugin light trapd00r/LS_COLORS atclone\"\u2026\" \u2013 generate shell script, but instead of passing it to eval , save it to file, atpull'%atclone' \u2013 do the same at any update of plugin (the atclone is being ran on the installation while the atpull hook is being ran on an update of the trapd00r/LS_COLORS plugin); the %atclone is just a special string that denotes that the atclone'' hook should be copied onto the atpull'' hook, pick\"clrs.zsh\" \u2013 source file clrs.zsh , the one that is generated, nocompile'!' \u2013 invokes compilation after the atclone'' ice-mod (the exclamation mark causes this). atload\"\u2026\" \u2013 additionally sets up the Zsh completion to use the colors provided by the trapd00r package. This way, except for the plugin installation and update, dircolors isn't ran, just normal sourcing is done. The every-day sourced file (i.e. clrs.zsh ) is even being compiled to speed up the loading.","title":"LS_COLORS Explanation"},{"location":"Multiple-p10k-configs/","text":"Multiple Powerlevel10k Configurations # The author wanted to indicate that he's working on a specific project through a significant change of the prompt. The Multiple Prompts setup was however too much \u2013 to change a prompt to a completely different one because of cd -ing into a directory felt to be a too big change. However, thanks to a user's request, a more balanced and quite ideal solution appeared \u2013 to switch romkatv/powerlevel10k configurations . The example setup is below. There's Asciinema recording demonstrating it. The needed steps include: Generate your configs with p10k configure , copying ~/.p10k.zsh to some other file like ~/.p10k_other.zsh . I suggest updating Powerlevel10k before generating the configs, as recently there was a code for hot reloading of the configs added. # Load within zshrc \u2013 for the instant prompt zplugin atload'!source ~/.p10k.zsh' lucid nocd zplugin load romkatv/powerlevel10k # Load ~/.p10k_zplugin.zsh when in ~/github/zplugin.git zplugin id-as'zplugin-prompt' nocd lucid \\ unload'[[ $PWD != */zplugin.git(|/*) ]]' \\ load'![[ $PWD = */zplugin.git(|/*) ]]' \\ atload'!source ~/.p10k_zplugin.zsh; _p9k_precmd' for \\ zdharma/null # Load ~/.p10k.zsh when in any other directory zplugin id-as'normal-prompt' nocd lucid \\ unload'[[ $PWD = */zplugin.git(|/*) ]]' \\ load'![[ $PWD != */zplugin.git(|/*) ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' for \\ zdharma/null For explanation on the used ice mods, see Multiple Prompts .","title":"Multiple p10k Configs"},{"location":"Multiple-p10k-configs/#multiple_powerlevel10k_configurations","text":"The author wanted to indicate that he's working on a specific project through a significant change of the prompt. The Multiple Prompts setup was however too much \u2013 to change a prompt to a completely different one because of cd -ing into a directory felt to be a too big change. However, thanks to a user's request, a more balanced and quite ideal solution appeared \u2013 to switch romkatv/powerlevel10k configurations . The example setup is below. There's Asciinema recording demonstrating it. The needed steps include: Generate your configs with p10k configure , copying ~/.p10k.zsh to some other file like ~/.p10k_other.zsh . I suggest updating Powerlevel10k before generating the configs, as recently there was a code for hot reloading of the configs added. # Load within zshrc \u2013 for the instant prompt zplugin atload'!source ~/.p10k.zsh' lucid nocd zplugin load romkatv/powerlevel10k # Load ~/.p10k_zplugin.zsh when in ~/github/zplugin.git zplugin id-as'zplugin-prompt' nocd lucid \\ unload'[[ $PWD != */zplugin.git(|/*) ]]' \\ load'![[ $PWD = */zplugin.git(|/*) ]]' \\ atload'!source ~/.p10k_zplugin.zsh; _p9k_precmd' for \\ zdharma/null # Load ~/.p10k.zsh when in any other directory zplugin id-as'normal-prompt' nocd lucid \\ unload'[[ $PWD = */zplugin.git(|/*) ]]' \\ load'![[ $PWD != */zplugin.git(|/*) ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' for \\ zdharma/null For explanation on the used ice mods, see Multiple Prompts .","title":"Multiple Powerlevel10k Configurations"},{"location":"Multiple-prompts/","text":"# Load when MYPROMPT == 1 zplugin ice load'![[ $MYPROMPT = 1 ]]' unload'![[ $MYPROMPT != 1 ]]' lucid zplugin load halfo/lambda-mod-zsh-theme # Load when MYPROMPT == 2 zplugin ice load'![[ $MYPROMPT = 2 ]]' unload'![[ $MYPROMPT != 2 ]]' \\ pick\"/dev/null\" multisrc\"{async,pure}.zsh\" \\ atload'!prompt_pure_precmd' lucid nocd zplugin load sindresorhus/pure # Load when MYPROMPT == 3 zplugin ice load'![[ $MYPROMPT = 3 ]]' unload'![[ $MYPROMPT != 3 ]]' \\ atload'!geometry::prompt' lucid nocd zplugin load geometry-zsh/geometry load'' \u2013 condition that when fulfilled will cause plugin to be loaded, unload'' \u2013 as above, but will unload plugin, note that plugins are loaded with zplugin load , not zplugin light , to track what plugin does, to be able to unload it, atload'!\u2026' \u2013 run the precmd hooks to make the prompts fully initialized when loaded in the middle of the prompt ( precmd hooks are being normally run before each new prompt); exclamation mark causes the effects of the functions to be tracked, to allow better unloading, conditions are checked every second, you can use conditions like ![[ $PWD == *github* ]] to change prompt after changing directory to *github* , the exclamation mark ![[ \u2026 ]] causes prompt to be reset after loading or unloading the plugin, pick'/dev/null' \u2013 disable sourcing of the default-found file, multisrc'' \u2013 source multiple files, lucid \u2013 don't show the under-prompt message that says e.g.: Loaded geometry-zsh/geometry , nocd \u2013 don't cd into the plugin's directory when executing the atload'' ice \u2013 it could make the path that's displayed by the theme to point to that directory.","title":"Multiple Prompts"},{"location":"NPM-Packages/","text":"Zsh/NPM Packages # Introduction # Zplugin can install NPM packages if they contain Zsh-related metadata (i.e.: the field \"zsh-data\" ) in the package.json . So basically what this means is that you can install plugins normally, like before, however with use of a metadata stored in the NPM package registry. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex. Motivation # The motivation for adding such functionality was: Zplugin is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zplugin has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at the NPM-registry with the plugin configurations (i.e.: ice-mods) stored in the package.json file? Introductory Example # This way, instead of the following command used to install fzf : zplugin lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zplugin pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zplugin anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zplugin update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zplugin is like apt-get and emerge in one! Pros Of Using Zplugin NPM-Support For Regular Software Installations # Using Zplugin to install software where one could use a regular package manager has several advantages: Pro: The Zplugin NPM packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zplugin ice-mods, e.g.: zplugin pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page). The Zsh-Packages Organization # The home for the packages is Zsh-Packages GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion. Adding Your Own Package # You can contact me to have the repository at the Zsh-Packages organization. Then, you'll only need to: Create an NPM account Invoke npm login . Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zplugin-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zplugin. Commit and invoke npm publish . That's all!","title":"Zsh/NPM Packages"},{"location":"NPM-Packages/#zshnpm_packages","text":"","title":"Zsh/NPM Packages"},{"location":"NPM-Packages/#introduction","text":"Zplugin can install NPM packages if they contain Zsh-related metadata (i.e.: the field \"zsh-data\" ) in the package.json . So basically what this means is that you can install plugins normally, like before, however with use of a metadata stored in the NPM package registry. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex.","title":"Introduction"},{"location":"NPM-Packages/#motivation","text":"The motivation for adding such functionality was: Zplugin is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zplugin has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at the NPM-registry with the plugin configurations (i.e.: ice-mods) stored in the package.json file?","title":"Motivation"},{"location":"NPM-Packages/#introductory_example","text":"This way, instead of the following command used to install fzf : zplugin lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zplugin pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zplugin anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zplugin update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zplugin is like apt-get and emerge in one!","title":"Introductory Example"},{"location":"NPM-Packages/#pros_of_using_zplugin_npm-support_for_regular_software_installations","text":"Using Zplugin to install software where one could use a regular package manager has several advantages: Pro: The Zplugin NPM packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zplugin ice-mods, e.g.: zplugin pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page).","title":"Pros Of Using Zplugin NPM-Support For Regular Software Installations"},{"location":"NPM-Packages/#the_zsh-packages_organization","text":"The home for the packages is Zsh-Packages GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion.","title":"The Zsh-Packages Organization"},{"location":"NPM-Packages/#adding_your_own_package","text":"You can contact me to have the repository at the Zsh-Packages organization. Then, you'll only need to: Create an NPM account Invoke npm login . Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zplugin-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zplugin. Commit and invoke npm publish . That's all!","title":"Adding Your Own Package"},{"location":"Private-Repositories/","text":"Loading Plugins From Private Repositories And Not Only # Introduction # In order to install and load a plugin whose repository is private - i.e.: requires providing credentials in order to log in \u2013 use the from'' ice in the following way: zplugin ice from\"psprint@github.com\" zplugin load psprint/fsh-auto-themes Explanation # The point is that when the from'' ice isn't one of gh , github , gl , gitlab , bb , bitbucket , nb , notabug , gh-r , github-rel then it is treaten as a domain name and inserted into the domain position into the clone url. I.e.: the following (more or less) git clone command is being run: git clone https://{from-ice-contents}/user/plugin In order to change the protocol, use the proto'' ice. Summary # By using this method you can clone plugins from e.g. GitHub Enterprise or embed the passwords as plain text in .zshrc . On The FSH-Auto-Themes Plugin # The plugin used in the example really exists and really is private. It's available to my sponsors. The plugin README is available here . My GitHub sponsors page \u2013 if you're interested in receiving the benefit: here .","title":"Loading Plugins From Private Repositories"},{"location":"Private-Repositories/#loading_plugins_from_private_repositories_and_not_only","text":"","title":"Loading Plugins From Private Repositories And Not Only"},{"location":"Private-Repositories/#introduction","text":"In order to install and load a plugin whose repository is private - i.e.: requires providing credentials in order to log in \u2013 use the from'' ice in the following way: zplugin ice from\"psprint@github.com\" zplugin load psprint/fsh-auto-themes","title":"Introduction"},{"location":"Private-Repositories/#explanation","text":"The point is that when the from'' ice isn't one of gh , github , gl , gitlab , bb , bitbucket , nb , notabug , gh-r , github-rel then it is treaten as a domain name and inserted into the domain position into the clone url. I.e.: the following (more or less) git clone command is being run: git clone https://{from-ice-contents}/user/plugin In order to change the protocol, use the proto'' ice.","title":"Explanation"},{"location":"Private-Repositories/#summary","text":"By using this method you can clone plugins from e.g. GitHub Enterprise or embed the passwords as plain text in .zshrc .","title":"Summary"},{"location":"Private-Repositories/#on_the_fsh-auto-themes_plugin","text":"The plugin used in the example really exists and really is private. It's available to my sponsors. The plugin README is available here . My GitHub sponsors page \u2013 if you're interested in receiving the benefit: here .","title":"On The FSH-Auto-Themes Plugin"},{"location":"Profiling-plugins/","text":"zplugin ice atinit'zmodload zsh/zprof' \\ atload'zprof | head -n 20; zmodload -u zsh/zprof' zplugin light zdharma/fast-syntax-highlighting atinit'' loads zsh/zprof module (shipped with Zsh) before loading the plugin \u2013 this starts the profiling, atload'' works after loading the plugin \u2013 shows profiling results ( zprof | head ), unloads zsh/zprof - this stops the profiling; in the effect, only a single plugin (in this case zdharma/fast-syntax-highlighting ) will be profiled while the rest of the e.g. zshrc processing will go on completely normally, the light loads without reporting enabled, so less Zplugin code is being run \u2013 no Zplugin code responsible for the tracking (i.e. the automatic data gathering, during loading of a plugin, for the reports and the possibility to unload the plugin) will be activated and the functions will not appear in the zprof report. example zprof report: num calls time self name --------------------------------------------------------------------------- 1) 1 57,76 57,76 57,91% 57,76 57,76 57,91% _zsh_highlight_bind_widgets 2) 1 25,81 25,81 25,88% 25,81 25,81 25,88% compinit 3) 4 10,71 2,68 10,74% 8,71 2,18 8,73% --zplg-shadow-autoload 4) 43 2,06 0,05 2,07% 2,06 0,05 2,07% -zplg-add-report 5) 8 1,98 0,25 1,98% 1,98 0,25 1,98% compdef 6) 1 2,85 2,85 2,85% 0,87 0,87 0,87% -zplg-compdef-replay 7) 1 0,68 0,68 0,68% 0,68 0,68 0,68% -zplg-shadow-off 8) 1 0,79 0,79 0,79% 0,49 0,49 0,49% add-zsh-hook 9) 1 0,47 0,47 0,47% 0,47 0,47 0,47% -zplg-shadow-on 10) 3 0,34 0,11 0,35% 0,34 0,11 0,35% (anon) 11) 4 10,91 2,73 10,94% 0,20 0,05 0,20% autoload 12) 1 0,19 0,19 0,19% 0,19 0,19 0,19% -fast-highlight-fill-option-variables 13) 1 25,98 25,98 26,05% 0,17 0,17 0,17% zpcompinit 14) 1 2,88 2,88 2,89% 0,03 0,03 0,03% zpcdreplay 15) 1 0,00 0,00 0,00% 0,00 0,00 0,00% -zplg-load-plugin ----------------------------------------------------------------------------------- the first column is the time is in milliseconds; it denotes the amount of time spent in a function in total so for example, --zplg-shadow-autoload consumed 10.71 ms of the execution time, the fourth column is also a time in milliseconds, but it denotes the amount of time spent on executing only of function's own code , i.e. it doesn't count the time spent in descendant functions that are called from the function; so for example, --zplg-shadow-autoload spent 8.71 ms on executing only its own code. the table is sorted on the self-time column.","title":"Profiling Plugins"},{"location":"Sourcing-multiple-files/","text":"Normally src'' can be used to specify additional file to source: zplugin ice pick\"powerless.zsh\" src\"utilities.zsh\" zplugin light martinrotter/powerless pick'' \u2013 provide main file to source (can be a pattern like *.sh \u2013 alphabetically first matched file is sourced), src'' \u2013 provide second file to source (not a pattern, plain file name) However, via atload'' ice one can provide simple loop to source more files: zplugin ice svn pick\"completion.zsh\" \\ atload'local f; for f in git.zsh misc.zsh; do \\ source $f \\ done' zplugin snippet OMZ::lib svn \u2013 use Subversion to clone OMZ::lib (the whole Oh My Zsh lib/ directory), note that atload'' uses apostrophes not double quotes, to literally put $f into the string, atload 's code is automatically being run within the snippet's (or plugin's) directory , atload'' code isn't tracked by Zplugin, i.e. cannot be unloaded, unless you load a plugin (not a snippet) with zplugin load \u2026 and prepend the value of the ice with exclamation mark, i.e. atload'!local f; for \u2026' , atload'' is executed after loading main files ( pick'' and src'' ones). The multisrc'' ice, which loads multiple files enumerated with spaces as the separator (e.g. multisrc'misc.zsh grep.zsh' ) and also using brace-expansion syntax (e.g. multisrc'{misc,grep}.zsh') . Example: zplugin ice svn pick\"completion.zsh\" multisrc'git.zsh \\ functions.zsh {history,grep}.zsh' zplugin snippet OMZ::lib The all possible ways to use the multisrc'' ice-mod: zplugin ice depth\"1\" multisrc=\"lib/{functions,misc}.zsh\" pick\"/dev/null\" zplugin load robbyrussell/oh-my-zsh # Can use patterns zplugin ice svn multisrc\"{funct*,misc}.zsh\" pick\"/dev/null\" zplugin snippet OMZ::lib array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"$array\" pick\"/dev/null\" zplugin snippet OMZ::lib # Will use the array's value at the moment of plugin load # \u2013 this can matter in case of using Turbo mode array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"\\$array\" pick\"/dev/null\" zplugin snippet OMZ::lib # Compatible with KSH_ARRAYS option array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"${array[*]}\" pick\"/dev/null\" zplugin snippet OMZ::lib # Compatible with KSH_ARRAYS option array=( {functions,misc}.zsh ) zplugin ice svn multisrc\"\\${array[*]}\" pick\"/dev/null\" zplugin snippet OMZ::lib zplugin ice svn multisrc\"misc.zsh functions.zsh\" pick\"/dev/null\" zplugin snippet OMZ::lib # Also \u2013 hack Zplugin: the ice's contents is simply `eval'-uated # like follows: eval \"reply=($multisrc)\". So it might get handy on # an occasion to pass code there, but first you must close the paren # and then don't forget to assign `reply', and to provide a trailing # opening paren. In the code be careful to not redefine any variable # used internally by Zplugin \u2013 e.g.: `i' is safe: array=( {functions,misc}.zsh ) zplugin ice svn multisrc'); local i; for i in $array; do \\ reply+=( ${i/.zsh/.sh} ); \\ done; ((1)' pick\"/dev/null\" zplugin snippet OMZ::lib","title":"Sourcing Multiple Files"},{"location":"Z-PLUGINS/","text":"z-plugins # What Are They? # They are Zplugin extensions. Note the difference in the name from the Zplugin \u2013 the dash and the plural form. What Can They Do? # Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand. How To Code Them? # Below is an example body of an atclone hook (taken from zdharma/z-p-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zdharma/z-p-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins. Details # There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"z-plugins"},{"location":"Z-PLUGINS/#z-plugins","text":"","title":"z-plugins"},{"location":"Z-PLUGINS/#what_are_they","text":"They are Zplugin extensions. Note the difference in the name from the Zplugin \u2013 the dash and the plural form.","title":"What Are They?"},{"location":"Z-PLUGINS/#what_can_they_do","text":"Add a new Zplugin subcommand (i.e. the command that\u2019s placed after the function zplugin \u2026 when calling Zplugin). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zplugin help subcommand.","title":"What Can They Do?"},{"location":"Z-PLUGINS/#how_to_code_them","text":"Below is an example body of an atclone hook (taken from zdharma/z-p-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook:<hook-type>|subcommand:<new-subcommand-name>} \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zdharma/z-p-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins.","title":"How To Code Them?"},{"location":"Z-PLUGINS/#details","text":"There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zplugin ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Details"},{"location":"atload-and-other-at-ices/","text":"The atload Ice (and other at\u2026 ices) # Introduction # There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zplugin ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example . Exclamation mark -preceded atload # The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded. Example # For example, in the following invocation: zplugin ice id-as'test' atload'!PATH+=:~/share' zplugin load zdharma/null the $PATH is being changed within atload ice. Zplugin's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zplugin unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT Practical example # The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zplugin load romkatv/powerlevel10k Summary # The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins (2)"},{"location":"atload-and-other-at-ices/#the_atload_ice_and_other_at_ices","text":"","title":"The atload Ice (and other at\u2026 ices)"},{"location":"atload-and-other-at-ices/#introduction","text":"There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zplugin ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example .","title":"Introduction"},{"location":"atload-and-other-at-ices/#exclamation_mark-preceded_atload","text":"The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded.","title":"Exclamation mark-preceded atload"},{"location":"atload-and-other-at-ices/#example","text":"For example, in the following invocation: zplugin ice id-as'test' atload'!PATH+=:~/share' zplugin load zdharma/null the $PATH is being changed within atload ice. Zplugin's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zplugin unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT","title":"Example"},{"location":"atload-and-other-at-ices/#practical_example","text":"The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zplugin load romkatv/powerlevel10k","title":"Practical example"},{"location":"atload-and-other-at-ices/#summary","text":"The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"crasis/","text":"Crasis \u2013 semigraphical interface to Zplugin # Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zplugin commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface. Installation & Basic Use # Install Zplugin and add following commands to .zshrc : zplugin light zdharma/zui zplugin light zdharma/zplugin-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later. Key Bindings # Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in) Screenshots # Code Documentation # Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Crasis"},{"location":"crasis/#crasis_semigraphical_interface_to_zplugin","text":"Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zplugin commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface.","title":"Crasis \u2013 semigraphical interface to Zplugin"},{"location":"crasis/#installation_basic_use","text":"Install Zplugin and add following commands to .zshrc : zplugin light zdharma/zui zplugin light zdharma/zplugin-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later.","title":"Installation &amp; Basic Use"},{"location":"crasis/#key_bindings","text":"Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in)","title":"Key Bindings"},{"location":"crasis/#screenshots","text":"","title":"Screenshots"},{"location":"crasis/#code_documentation","text":"Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Code Documentation"},{"location":"declare-zsh/","text":"declare-zsh # declare-zsh is a parser for zplugin commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zplugin load {removed-plugin} command together with the possible associated zplugin ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file). Examples & Screenshots # Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] zdharma/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!: Usage # Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"declare-zsh"},{"location":"declare-zsh/#declare-zsh","text":"declare-zsh is a parser for zplugin commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zplugin load {removed-plugin} command together with the possible associated zplugin ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file).","title":"declare-zsh"},{"location":"declare-zsh/#examples_screenshots","text":"Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] zdharma/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!:","title":"Examples &amp; Screenshots"},{"location":"declare-zsh/#usage","text":"Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"Usage"},{"location":"fsh-auto-themes/","text":"fsh-auto-themes # Introduction # In-short, fsh-auto-themes is a plugin that implements Zshell per-directory themes for zdharma/fast-syntax-highlighting , i.e.: for a plugin that applies colors to the commands you type in the shell, (see a screenshot ). With fsh-auto-themes you'll be able to switch the FSH theme at the moment of entering a particular directory. Operation # This plugin activates after changing current directory in the shell session. It then searches for .fsh-theme file in that new directory or in any upper directory. Example .fsh-theme file contents: q-jmnemonic First line : a name of a theme or a path to a theme. The path can use the shorthands supported by fast-theme , e.g.: XDG:x-paragon will point to the file ~/.config/fsh/x-paragon.ini (unless the $XDG_CONFIG_HOME is being set to different directory than ~/.config ). See fast-theme --help for more information and other shorthands. Second line : a name or a path of an overlay (an overlay is a theme-like file that overwrites every theme's settings; you can use it to impose your own customizations over any theme). The plugin will switch current theme to the one in the file and also apply the overlay found in the file. One of the lines can be empty. If .fsh-theme will not be found, the default theme (the one currently set with the fast-theme tool) will be restored. Example # Example operation of the plugin: Installation # Example zdharma/zplugin invocation: zplugin ice from\"<USERNAME>@github.com\" zplugin light psprint/fsh-auto-themes With Turbo Mode : zplugin ice wait'1' lucid from\"<USERNAME>@github.com\" zplugin light psprint/fsh-auto-themes","title":"fsh-auto-themes"},{"location":"fsh-auto-themes/#fsh-auto-themes","text":"","title":"fsh-auto-themes"},{"location":"fsh-auto-themes/#introduction","text":"In-short, fsh-auto-themes is a plugin that implements Zshell per-directory themes for zdharma/fast-syntax-highlighting , i.e.: for a plugin that applies colors to the commands you type in the shell, (see a screenshot ). With fsh-auto-themes you'll be able to switch the FSH theme at the moment of entering a particular directory.","title":"Introduction"},{"location":"fsh-auto-themes/#operation","text":"This plugin activates after changing current directory in the shell session. It then searches for .fsh-theme file in that new directory or in any upper directory. Example .fsh-theme file contents: q-jmnemonic First line : a name of a theme or a path to a theme. The path can use the shorthands supported by fast-theme , e.g.: XDG:x-paragon will point to the file ~/.config/fsh/x-paragon.ini (unless the $XDG_CONFIG_HOME is being set to different directory than ~/.config ). See fast-theme --help for more information and other shorthands. Second line : a name or a path of an overlay (an overlay is a theme-like file that overwrites every theme's settings; you can use it to impose your own customizations over any theme). The plugin will switch current theme to the one in the file and also apply the overlay found in the file. One of the lines can be empty. If .fsh-theme will not be found, the default theme (the one currently set with the fast-theme tool) will be restored.","title":"Operation"},{"location":"fsh-auto-themes/#example","text":"Example operation of the plugin:","title":"Example"},{"location":"fsh-auto-themes/#installation","text":"Example zdharma/zplugin invocation: zplugin ice from\"<USERNAME>@github.com\" zplugin light psprint/fsh-auto-themes With Turbo Mode : zplugin ice wait'1' lucid from\"<USERNAME>@github.com\" zplugin light psprint/fsh-auto-themes","title":"Installation"},{"location":"id-as/","text":"Nickname a plugin or snippet # Zplugin supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zplugin ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zplugin light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zplugin ice as\"completion\" id-as\"dc-complete\" zplugin load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zplugin list | grep -i dc-complete dc-complete Issuing zplugin report dc-complete also works, so as other Zplugin commands: ~ zplugin report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zplugin ice as\"program\" id-as\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zplugin update git-unique , zplugin delete git-unique and other will work normally and e.g. zplugin times will show the nickname -ID git-unique instead of the long URL. id-as'auto' # There's a special value to the id-as'' ice \u2013 auto . It causes the nickname to be automatically set to the last component of the plugin name or snippet URL. For example: zplugin ice as\"program\" id-as\"auto\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique will work the same as before, i.e.: like if the ice used was id-as'git-unique' . Example with a plugin: # Will work as if id-as'zsh-autopair' was passed zplugin ice wait lucid id-as\"auto\" zplugin load hlissner/zsh-autopair","title":"Nickname a Plugin or Snippet"},{"location":"id-as/#nickname_a_plugin_or_snippet","text":"Zplugin supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zplugin ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zplugin light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zplugin ice as\"completion\" id-as\"dc-complete\" zplugin load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zplugin list | grep -i dc-complete dc-complete Issuing zplugin report dc-complete also works, so as other Zplugin commands: ~ zplugin report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zplugin ice as\"program\" id-as\"git-unique\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zplugin update git-unique , zplugin delete git-unique and other will work normally and e.g. zplugin times will show the nickname -ID git-unique instead of the long URL.","title":"Nickname a plugin or snippet"},{"location":"id-as/#id-asauto","text":"There's a special value to the id-as'' ice \u2013 auto . It causes the nickname to be automatically set to the last component of the plugin name or snippet URL. For example: zplugin ice as\"program\" id-as\"auto\" zplugin snippet https://github.com/Osse/git-scripts/blob/master/git-unique will work the same as before, i.e.: like if the ice used was id-as'git-unique' . Example with a plugin: # Will work as if id-as'zsh-autopair' was passed zplugin ice wait lucid id-as\"auto\" zplugin load hlissner/zsh-autopair","title":"id-as'auto'"},{"location":"preinstalling-plugins/","text":"Preinstalling Plugins # If you create a Docker image that uses Zplugin, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Preinstalling Plugins"},{"location":"preinstalling-plugins/#preinstalling_plugins","text":"If you create a Docker image that uses Zplugin, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Preinstalling Plugins"},{"location":"wrap-track/","text":"The wrap-track Ice # The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zplugin ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026 Example # Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zplugin load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22 _gitstatus_process_response_POWERLEVEL9K Autoload _gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function: _p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026) Summary # As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins"},{"location":"wrap-track/#the_wrap-track_ice","text":"The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zplugin ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026","title":"The wrap-track Ice"},{"location":"wrap-track/#example","text":"Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zplugin ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zplugin load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22 _gitstatus_process_response_POWERLEVEL9K Autoload _gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function: _p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026)","title":"Example"},{"location":"wrap-track/#summary","text":"As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"z-a-bin-gem-node/","text":"z-a-bin-gem-node # Introduction # A Zsh-Zplugin annex (i.e. an extension) that provides functionality, which allows to: Run programs and scripts without adding anything to $PATH , Install and run Ruby gems and Node modules from within a local directory with $GEM_HOME and $NODE_PATH automatically set, Run programs, scripts and functions with automatic cd into the plugin or snippet directory, plus also with automatic standard output & standard error redirecting. Source scripts through an automatically created function with the above $GEM_HOME , $NODE_PATH and cd features available, Create the so called shims known from rbenv \u2013 the same feature as the first item of this enumaration \u2013 of running a program without adding anything to $PATH with all of the above features, however through an automatic script created in $ZPFX/bin , not a function (the first item uses a function-based mechanism), Automatic updates of Ruby gems and Node modules during regular plugin and snippet updates with zplugin update \u2026 . Installation # Simply load like a regular plugin, i.e.: zplugin light zplugin/z-a-bin-gem-node After executing this command you can then use the dl'' and patch'' ice-mods. How it works \u2013 bird's-eye view # Below is a diagram explaining the major feature \u2013 exposing a binary program or script through a Zsh function of the same name: This way there is no need to add anything to $PATH \u2013 z-a-bin-gem-node will automatically create a function that will wrap the binary and provide it on the command line like if it was being placed in the $PATH . Also, like mentioned in the enumeration, the function can automatically export $GEM_HOME , $NODE_PATH shell variables and also automatically cd into the plugin or snippet directory right before executing the binary and then cd back to the original directory after the execution is finished. Also, like already mentioned, instead of the function an automatically created script \u2013 so called shim \u2013 can be used for the same purpose and with the same functionality. How it works, in detail # Suppose that you would want to install junegunn/fzf-bin plugin from GitHub Releases, which contains only single file \u2013 the fzf binary for the selected architecture. It is possible to do it in the standard way \u2013 by adding the plugin's directory to the $PATH : zplugin ice as\"command\" from\"github-rel\" zplugin load junegunn/fzf-bin After this command, the $PATH variable will contain e.g.: % print $PATH /home/sg/.zplugin/plugins/junegunn---fzf-bin:/bin:/usr/bin:/usr/sbin:/sbin For many such programs loaded as plugins the PATH can become quite cluttered. I've had 26 entries before switching to z-a-bin-gem-node . To solve this, load with use of fbin'' ice provided and handled by z-a-bin-gem-node : zplugin ice from\"gh-r\" fbin\"fzf\" zplugin load junegunn/fzf-bin The $PATH will remain unchanged and an fzf function will be created: % which fzf fzf () { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } Running the function will forward the call to the program accessed through an embedded path to it. Thus, no $PATH changes are needed! The Ice Modifiers Provided By The Annex # There are 7 ice-modifiers provided and handled by the annex. They are: fbin'' \u2013 creates functions for binaries and scripts, sbin'' \u2013 creates shims for binaries and scripts, gem'' \u2013 installs and updates gems + creates functions for gems' binaries, node'' \u2013 installs and updates node_modules + creates functions for binaries of the modules, fmod'' \u2013 creates wrapping functions for other functions, fsrc'' \u2013 creates functions that source given scripts, ferc'' \u2013 the same as fsrc'' , but using an alternate script-loading method. The ice-modifiers in detail: 1. fbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -> {name-of-the-function}]; \u2026' # Creates a wrapper function of the name the same as the last segment of the path or as {name-of-the-function} . The optional preceding flags mean: g \u2013 set $GEM_HOME variable, n \u2013 set $NODE_PATH variable, c \u2013 cd to the plugin's directory before running the function and then cd back after it has been run, N \u2013 append &>/dev/null to the call of the binary, i.e. redirect both standard output and standard error to /dev/null , E \u2013 append 2>/dev/null to the call of the binary, i.e. redirect standard error to /dev/null , O \u2013 append >/dev/null to the call of the binary, i.e. redirect standard output to /dev/null . Example: % zplugin ice from\"gh-r\" fbin\"g:fzf -> myfzf\" % zplugin load junegunn/fzf-bin % which myfzf myfzf () { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" local -x GEM_HOME=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } 2. gem'{gem-name}; \u2026' # gem'[{path-to-binary} <-] !{gem-name} [-> {name-of-the-function}]; \u2026' # Installs the gem of name {gem-name} with $GEM_HOME set to the plugin's or snippet's directory. In other words, the gem and its dependencies will be installed locally in that directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zplugin ice gem'!asciidoctor' % zplugin load zdharma/null % which asciidoctor asciidoctor () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null/bin\" local -x GEM_HOME=\"/home/sg/.zplugin/plugins/zdharma---null\" \"$bindir\"/\"asciidoctor\" \"$@\" } 3. node'{node-module}; \u2026' # node'[{path-to-binary} <-] !{node-module} [-> {name-of-the-function}]; \u2026' # Installs the node module of name {node-module} inside the plugin's or snippet's directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zplugin delete zdharma/null Delete /home/sg/.zplugin/plugins/zdharma---null? [yY/n\u2026] y Done (action executed, exit code: 0) % zplugin ice node'remark <- !remark-cli -> remark; remark-man' % zplugin load zdharma/null \u2026installation messages\u2026 % which remark remark () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null/node_modules/.bin\" local -x NODE_PATH=\"/home/sg/.zplugin/plugins/zdharma---null\"/node_modules \"$bindir\"/\"remark\" \"$@\" } In this case the name of the binary program provided by the node module is different from its name, hence the second form with the b <- a -> c syntax has been used. 4. fmod'[{g|n|c|N|E|O}:]{function-name}; \u2026' # fmod'[{g|n|c|N|E|O}:]{function-name} -> {wrapping-function-name}; \u2026' # It wraps given function with the ability to set $GEM_HOME , etc. \u2013 the meaning of the g , n and c flags is the same as in the fbin'' ice. Example: % myfun() { pwd; ls -1 } % zplugin ice fmod'cgn:myfun' % zplugin load zdharma/null % which myfun myfun () { local -x GEM_HOME=\"/home/sg/.zplugin/plugins/zdharma---null\" local -x NODE_PATH=\"/home/sg/.zplugin/plugins/zdharma---null\"/node_modules local oldpwd=\"/home/sg/.zplugin/plugins/zplugin---z-a-bin-gem-node\" () { setopt localoptions noautopushd builtin cd -q \"/home/sg/.zplugin/plugins/zdharma---null\" } \"myfun--za-bgn-orig\" \"$@\" () { setopt localoptions noautopushd builtin cd -q \"$oldpwd\" } } % myfun /home/sg/.zplugin/plugins/zdharma---null LICENSE README.md 5. sbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -> {name-of-the-script}]; \u2026' # It creates the so called shim known from rbenv \u2013 a wrapper script that forwards the call to the actual binary. The script is created always under the same, standard and single $PATH entry: $ZPFX/bin (which is ~/.zplugin/polaris/bin by default). The flags have the same meaning as with fbin'' ice. Example: % zplugin delete junegunn/fzf-bin Delete /home/sg/.zplugin/plugins/junegunn---fzf-bin? [yY/n\u2026] y Done (action executed, exit code: 0) % zplugin ice from\"gh-r\" sbin\"fzf\" % zplugin load junegunn/fzf-bin \u2026installation messages\u2026 % cat $ZPFX/bin/fzf #!/usr/bin/env zsh function fzf { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } fzf \"$@\" 6. fsrc'[{g|n|c|N|E|O}:]{path-to-script}[ -> {name-of-the-function}]; \u2026' # 7. ferc'[{g|n|c|N|E|O}:]{path-to-script}[ -> {name-of-the-function}]; \u2026' # Creates a wrapper function that at each invocation sources the given file. The second ice, ferc'' works the same with the single difference that it uses eval \"$(<{path-to-script})\" instead of source \"{path-to-script}\" to load the script. Example: % zplugin ice fsrc\"myscript -> myfunc\" ferc\"myscript\" % zplugin load zdharma/null % which myfunc myfunc () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null\" () { source \"$bindir\"/\"myscript\" } \"$@\" } % which myscript myscript () { local bindir=\"/home/sg/.zplugin/snippets/OMZ::plugins--git/git.plugin.zsh\" () { eval \"$(<\"$bindir\"/\"myscript\")\" } \"$@\" }","title":"z-a-bin-gem-node"},{"location":"z-a-bin-gem-node/#z-a-bin-gem-node","text":"","title":"z-a-bin-gem-node"},{"location":"z-a-bin-gem-node/#introduction","text":"A Zsh-Zplugin annex (i.e. an extension) that provides functionality, which allows to: Run programs and scripts without adding anything to $PATH , Install and run Ruby gems and Node modules from within a local directory with $GEM_HOME and $NODE_PATH automatically set, Run programs, scripts and functions with automatic cd into the plugin or snippet directory, plus also with automatic standard output & standard error redirecting. Source scripts through an automatically created function with the above $GEM_HOME , $NODE_PATH and cd features available, Create the so called shims known from rbenv \u2013 the same feature as the first item of this enumaration \u2013 of running a program without adding anything to $PATH with all of the above features, however through an automatic script created in $ZPFX/bin , not a function (the first item uses a function-based mechanism), Automatic updates of Ruby gems and Node modules during regular plugin and snippet updates with zplugin update \u2026 .","title":"Introduction"},{"location":"z-a-bin-gem-node/#installation","text":"Simply load like a regular plugin, i.e.: zplugin light zplugin/z-a-bin-gem-node After executing this command you can then use the dl'' and patch'' ice-mods.","title":"Installation"},{"location":"z-a-bin-gem-node/#how_it_works_birds-eye_view","text":"Below is a diagram explaining the major feature \u2013 exposing a binary program or script through a Zsh function of the same name: This way there is no need to add anything to $PATH \u2013 z-a-bin-gem-node will automatically create a function that will wrap the binary and provide it on the command line like if it was being placed in the $PATH . Also, like mentioned in the enumeration, the function can automatically export $GEM_HOME , $NODE_PATH shell variables and also automatically cd into the plugin or snippet directory right before executing the binary and then cd back to the original directory after the execution is finished. Also, like already mentioned, instead of the function an automatically created script \u2013 so called shim \u2013 can be used for the same purpose and with the same functionality.","title":"How it works \u2013 bird's-eye view"},{"location":"z-a-bin-gem-node/#how_it_works_in_detail","text":"Suppose that you would want to install junegunn/fzf-bin plugin from GitHub Releases, which contains only single file \u2013 the fzf binary for the selected architecture. It is possible to do it in the standard way \u2013 by adding the plugin's directory to the $PATH : zplugin ice as\"command\" from\"github-rel\" zplugin load junegunn/fzf-bin After this command, the $PATH variable will contain e.g.: % print $PATH /home/sg/.zplugin/plugins/junegunn---fzf-bin:/bin:/usr/bin:/usr/sbin:/sbin For many such programs loaded as plugins the PATH can become quite cluttered. I've had 26 entries before switching to z-a-bin-gem-node . To solve this, load with use of fbin'' ice provided and handled by z-a-bin-gem-node : zplugin ice from\"gh-r\" fbin\"fzf\" zplugin load junegunn/fzf-bin The $PATH will remain unchanged and an fzf function will be created: % which fzf fzf () { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } Running the function will forward the call to the program accessed through an embedded path to it. Thus, no $PATH changes are needed!","title":"How it works, in detail"},{"location":"z-a-bin-gem-node/#the_ice_modifiers_provided_by_the_annex","text":"There are 7 ice-modifiers provided and handled by the annex. They are: fbin'' \u2013 creates functions for binaries and scripts, sbin'' \u2013 creates shims for binaries and scripts, gem'' \u2013 installs and updates gems + creates functions for gems' binaries, node'' \u2013 installs and updates node_modules + creates functions for binaries of the modules, fmod'' \u2013 creates wrapping functions for other functions, fsrc'' \u2013 creates functions that source given scripts, ferc'' \u2013 the same as fsrc'' , but using an alternate script-loading method. The ice-modifiers in detail:","title":"The Ice Modifiers Provided By The Annex"},{"location":"z-a-bin-gem-node/#1_fbingncneopath-to-binary_-gt_name-of-the-function","text":"Creates a wrapper function of the name the same as the last segment of the path or as {name-of-the-function} . The optional preceding flags mean: g \u2013 set $GEM_HOME variable, n \u2013 set $NODE_PATH variable, c \u2013 cd to the plugin's directory before running the function and then cd back after it has been run, N \u2013 append &>/dev/null to the call of the binary, i.e. redirect both standard output and standard error to /dev/null , E \u2013 append 2>/dev/null to the call of the binary, i.e. redirect standard error to /dev/null , O \u2013 append >/dev/null to the call of the binary, i.e. redirect standard output to /dev/null . Example: % zplugin ice from\"gh-r\" fbin\"g:fzf -> myfzf\" % zplugin load junegunn/fzf-bin % which myfzf myfzf () { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" local -x GEM_HOME=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" }","title":"1. fbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#2_gemgem-name","text":"","title":"2. gem'{gem-name}; \u2026'"},{"location":"z-a-bin-gem-node/#gempath-to-binary_lt-_gem-name_-gt_name-of-the-function","text":"Installs the gem of name {gem-name} with $GEM_HOME set to the plugin's or snippet's directory. In other words, the gem and its dependencies will be installed locally in that directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zplugin ice gem'!asciidoctor' % zplugin load zdharma/null % which asciidoctor asciidoctor () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null/bin\" local -x GEM_HOME=\"/home/sg/.zplugin/plugins/zdharma---null\" \"$bindir\"/\"asciidoctor\" \"$@\" }","title":"gem'[{path-to-binary} &lt;-] !{gem-name} [-&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#3_nodenode-module","text":"","title":"3. node'{node-module}; \u2026'"},{"location":"z-a-bin-gem-node/#nodepath-to-binary_lt-_node-module_-gt_name-of-the-function","text":"Installs the node module of name {node-module} inside the plugin's or snippet's directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zplugin delete zdharma/null Delete /home/sg/.zplugin/plugins/zdharma---null? [yY/n\u2026] y Done (action executed, exit code: 0) % zplugin ice node'remark <- !remark-cli -> remark; remark-man' % zplugin load zdharma/null \u2026installation messages\u2026 % which remark remark () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null/node_modules/.bin\" local -x NODE_PATH=\"/home/sg/.zplugin/plugins/zdharma---null\"/node_modules \"$bindir\"/\"remark\" \"$@\" } In this case the name of the binary program provided by the node module is different from its name, hence the second form with the b <- a -> c syntax has been used.","title":"node'[{path-to-binary} &lt;-] !{node-module} [-&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#4_fmodgncneofunction-name","text":"","title":"4. fmod'[{g|n|c|N|E|O}:]{function-name}; \u2026'"},{"location":"z-a-bin-gem-node/#fmodgncneofunction-name_-gt_wrapping-function-name","text":"It wraps given function with the ability to set $GEM_HOME , etc. \u2013 the meaning of the g , n and c flags is the same as in the fbin'' ice. Example: % myfun() { pwd; ls -1 } % zplugin ice fmod'cgn:myfun' % zplugin load zdharma/null % which myfun myfun () { local -x GEM_HOME=\"/home/sg/.zplugin/plugins/zdharma---null\" local -x NODE_PATH=\"/home/sg/.zplugin/plugins/zdharma---null\"/node_modules local oldpwd=\"/home/sg/.zplugin/plugins/zplugin---z-a-bin-gem-node\" () { setopt localoptions noautopushd builtin cd -q \"/home/sg/.zplugin/plugins/zdharma---null\" } \"myfun--za-bgn-orig\" \"$@\" () { setopt localoptions noautopushd builtin cd -q \"$oldpwd\" } } % myfun /home/sg/.zplugin/plugins/zdharma---null LICENSE README.md","title":"fmod'[{g|n|c|N|E|O}:]{function-name} -&gt; {wrapping-function-name}; \u2026'"},{"location":"z-a-bin-gem-node/#5_sbingncneopath-to-binary_-gt_name-of-the-script","text":"It creates the so called shim known from rbenv \u2013 a wrapper script that forwards the call to the actual binary. The script is created always under the same, standard and single $PATH entry: $ZPFX/bin (which is ~/.zplugin/polaris/bin by default). The flags have the same meaning as with fbin'' ice. Example: % zplugin delete junegunn/fzf-bin Delete /home/sg/.zplugin/plugins/junegunn---fzf-bin? [yY/n\u2026] y Done (action executed, exit code: 0) % zplugin ice from\"gh-r\" sbin\"fzf\" % zplugin load junegunn/fzf-bin \u2026installation messages\u2026 % cat $ZPFX/bin/fzf #!/usr/bin/env zsh function fzf { local bindir=\"/home/sg/.zplugin/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } fzf \"$@\"","title":"5. sbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -&gt; {name-of-the-script}]; \u2026'"},{"location":"z-a-bin-gem-node/#6_fsrcgncneopath-to-script_-gt_name-of-the-function","text":"","title":"6. fsrc'[{g|n|c|N|E|O}:]{path-to-script}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#7_fercgncneopath-to-script_-gt_name-of-the-function","text":"Creates a wrapper function that at each invocation sources the given file. The second ice, ferc'' works the same with the single difference that it uses eval \"$(<{path-to-script})\" instead of source \"{path-to-script}\" to load the script. Example: % zplugin ice fsrc\"myscript -> myfunc\" ferc\"myscript\" % zplugin load zdharma/null % which myfunc myfunc () { local bindir=\"/home/sg/.zplugin/plugins/zdharma---null\" () { source \"$bindir\"/\"myscript\" } \"$@\" } % which myscript myscript () { local bindir=\"/home/sg/.zplugin/snippets/OMZ::plugins--git/git.plugin.zsh\" () { eval \"$(<\"$bindir\"/\"myscript\")\" } \"$@\" }","title":"7. ferc'[{g|n|c|N|E|O}:]{path-to-script}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-man/","text":"Introduction # A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-a-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zplugin/z-a-man Examples # Main manual (of the project): Code documentation for the plugin.zsh file (of the project): Installation # Simply load like any other plugin, i.e.: the following command will install the extension within Zplugin: zplugin light zplugin/z-a-man","title":"z-a-man"},{"location":"z-a-man/#introduction","text":"A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-a-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zplugin/z-a-man","title":"Introduction"},{"location":"z-a-man/#examples","text":"Main manual (of the project): Code documentation for the plugin.zsh file (of the project):","title":"Examples"},{"location":"z-a-man/#installation","text":"Simply load like any other plugin, i.e.: the following command will install the extension within Zplugin: zplugin light zplugin/z-a-man","title":"Installation"},{"location":"z-a-patch-dl/","text":"Introduction # A Zsh-Zplugin extension (i.e. an annex ) that downloads files and applies patches. It adds two ice modifiers: zplugin ice dl'{URL} [-> {optional-output-file-name}]; \u2026' \u2026 and zplugin ice patch'{file-name-with-the-patch-to-apply}; \u2026' \u2026 The annex (i.e. Zplugin extension) will download the given {URL} under the path {optional-output-file-name} (if no file name given, then it is taken from last segment of the URL) in case of the dl'' ice-mod, and apply a patch given by the {file-name-with-the-patch-to-apply} in case of the patch'' ice-mod. You can use this functionality to download and apply patches. For example, to install fbterm , two patches are being needed, one to fix the operation, the other one to fix the build: zplugin ice \\ as\"command\" pick\"$ZPFX/bin/fbterm\" \\ dl\"https://bugs.archlinux.org/task/46860?getfile=13513 -> ins.patch\" \\ dl\"https://aur.archlinux.org/cgit/aur.git/plain/0001-Fix-build-with-gcc-6.patch?h=fbterm-git\" \\ patch\"ins.patch; 0001-Fix-build-with-gcc-6.patch\" \\ atclone\"./configure --prefix=$ZPFX\" \\ atpull\"%atclone\" \\ make\"install\" reset zplugin load izmntuk/fbterm This command will result in: Installation # Simply load like a plugin, i.e. the following will add the annex to Zplugin: zplugin light zplugin/z-a-patch-dl After executing this command you can then use the dl'' and patch'' ice-mods.","title":"z-a-patch-dl"},{"location":"z-a-patch-dl/#introduction","text":"A Zsh-Zplugin extension (i.e. an annex ) that downloads files and applies patches. It adds two ice modifiers: zplugin ice dl'{URL} [-> {optional-output-file-name}]; \u2026' \u2026 and zplugin ice patch'{file-name-with-the-patch-to-apply}; \u2026' \u2026 The annex (i.e. Zplugin extension) will download the given {URL} under the path {optional-output-file-name} (if no file name given, then it is taken from last segment of the URL) in case of the dl'' ice-mod, and apply a patch given by the {file-name-with-the-patch-to-apply} in case of the patch'' ice-mod. You can use this functionality to download and apply patches. For example, to install fbterm , two patches are being needed, one to fix the operation, the other one to fix the build: zplugin ice \\ as\"command\" pick\"$ZPFX/bin/fbterm\" \\ dl\"https://bugs.archlinux.org/task/46860?getfile=13513 -> ins.patch\" \\ dl\"https://aur.archlinux.org/cgit/aur.git/plain/0001-Fix-build-with-gcc-6.patch?h=fbterm-git\" \\ patch\"ins.patch; 0001-Fix-build-with-gcc-6.patch\" \\ atclone\"./configure --prefix=$ZPFX\" \\ atpull\"%atclone\" \\ make\"install\" reset zplugin load izmntuk/fbterm This command will result in:","title":"Introduction"},{"location":"z-a-patch-dl/#installation","text":"Simply load like a plugin, i.e. the following will add the annex to Zplugin: zplugin light zplugin/z-a-patch-dl After executing this command you can then use the dl'' and patch'' ice-mods.","title":"Installation"},{"location":"z-a-submods/","text":"Introduction # A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Installation # Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"z-a-submods"},{"location":"z-a-submods/#introduction","text":"A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions","title":"Introduction"},{"location":"z-a-submods/#installation","text":"Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"Installation"},{"location":"z-a-test/","text":"Introduction # Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode: Installation # Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"z-a-test"},{"location":"z-a-test/#introduction","text":"Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode:","title":"Introduction"},{"location":"z-a-test/#installation","text":"Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"Installation"},{"location":"z-p-man/","text":"Introduction # A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-p-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zdharma/z-p-man Screenshots # Main manual (of the project): Code documentation for the plugin.zsh file (of the project): Installation # Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-man","title":"Z p man"},{"location":"z-p-man/#introduction","text":"A Zplugin extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-p-man # View the code documentation (via the full plugin name, as demonstrated) zman -c zdharma/z-p-man","title":"Introduction"},{"location":"z-p-man/#screenshots","text":"Main manual (of the project): Code documentation for the plugin.zsh file (of the project):","title":"Screenshots"},{"location":"z-p-man/#installation","text":"Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-man","title":"Installation"},{"location":"z-p-submods/","text":"Introduction # A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions Installation # Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"Z p submods"},{"location":"z-p-submods/#introduction","text":"A z-plugin (i.e. a plugin for the Zplugin \u2013 more information ) that allows Zplugin to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zplugin update \u2026 command. This z-plugin adds submods'' ice to Zplugin which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the z-plugin and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zplugin ice svn submods'zsh-users/zsh-autosuggestions -> external' zplugin snippet PZT::modules/autosuggestions","title":"Introduction"},{"location":"z-p-submods/#installation","text":"Simply load as a plugin. The following command will install the z-plugin within Zplugin: zplugin light zdharma/z-p-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"Installation"},{"location":"z-p-test/","text":"Introduction # Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode: Installation # Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"Z p test"},{"location":"z-p-test/#introduction","text":"Zplugin extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zplugin light zdharma/z-p-test Example activation in the default quiet mode: Example activation in non-quiet mode:","title":"Introduction"},{"location":"z-p-test/#installation","text":"Simply load as a plugin. This will install the extension within Zplugin: zplugin light zdharma/z-p-test","title":"Installation"},{"location":"zplugin-autoload.zsh/","text":"zplugin-autoload.zsh(1) # NAME # zplugin-autoload.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-any-to-uspl2 -zplg-at-eval -zplg-build-module -zplg-cd -zplg-cdisable -zplg-cenable -zplg-changes -zplg-check-comp-consistency -zplg-check-which-completions-are-enabled -zplg-check-which-completions-are-installed -zplg-clear-completions -zplg-clear-report-for -zplg-compiled -zplg-compile-uncompile-all -zplg-compinit -zplg-compute-ice -zplg-confirm -zplg-create -zplg-delete -zplg-diff-env-compute -zplg-diff-functions-compute -zplg-diff-options-compute -zplg-diff-parameter-compute -zplg-edit -zplg-exists-message -zplg-find-completions-of-plugin -zplg-format-env -zplg-format-functions -zplg-format-options -zplg-format-parameter -zplg-get-completion-owner -zplg-get-completion-owner-uspl2col -zplg-get-path -zplg-glance -zplg-help -zplg-list-bindkeys -zplg-list-compdef-replay -zplg-ls -zplg-module -zplg-prepare-readlink -zplg-recall -zplg-recently -zplg-restore-extendedglob -zplg-save-set-extendedglob -zplg-search-completions -zplg-self-update -zplg-show-all-reports -zplg-show-completions -zplg-show-debug-report -zplg-show-registered-plugins -zplg-show-report -zplg-show-times -zplg-show-zstatus -zplg-stress -zplg-uncompile-plugin -zplg-uninstall-completions -zplg-unload -zplg-update-or-status -zplg-update-or-status-all -zplg-update-or-status-snippet AUTOLOAD compinit DETAILS # Script Body # Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source -zplg-any-to-uspl2 # Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-clear-report-for -zplg-exists-message -zplg-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-update-or-status -zplg-build-module # Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: -zplg-build-module `-- -zplg-module Uses feature(s): trap Called by: -zplg-module -zplg-cd # Jumps to plugin's directory (in Zplugin's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-cd `-- -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-cdisable # Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: -zplg-cdisable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin -zplg-cenable # Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: -zplg-cenable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin -zplg-changes # Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: -zplg-changes |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-check-comp-consistency # Zplugin creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-cdisable -zplg-cenable -zplg-check-which-completions-are-enabled # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-check-which-completions-are-installed # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-clear-completions # Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: -zplg-clear-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-clear-report-for # Clears all report data for given user/plugin. This is done by resetting all related global ZPLG_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: -zplg-clear-report-for `-- -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-unload zplugin.zsh/-zplg-clear-debug-report -zplg-compiled # Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: -zplg-compiled |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-compile-uncompile-all # Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: -zplg-compile-uncompile-all |-- -zplg-uncompile-plugin | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-compinit # User-exposed `compinit' frontend which first ensures that all completions managed by Zplugin are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zplugin's completions. No arguments. Has 23 line(s). Calls functions: -zplg-compinit |-- compinit `-- zplugin-install.zsh/-zplg-forget-completion Uses feature(s): autoload , unfunction Called by: zplugin.zsh/zplugin -zplg-compute-ice # Computes ZPLG_ICE array (default, it can be specified via $3) from a) input ZPLG_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZPLG_ICE[svn] is not set). Can also pack resulting ices into ZPLG_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZPLG_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZPLG_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Called by: -zplg-recall -zplg-update-or-status-snippet -zplg-update-or-status -zplg-confirm # Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: -zplg-delete -zplg-create # Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: -zplg-create |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-delete # Deletes plugin's or snippet's directory (in Zplugin's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: -zplg-delete |-- -zplg-confirm |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-diff-env-compute # Computes ZPLG_PATH, ZPLG_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by -zplg-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-functions-compute # Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by -zplg-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-options-compute # Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by -zplg-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-diff-parameter-compute # Computes ZPLG_PARAMETERS_PRE, ZPLG_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by -zplg-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload -zplg-edit # Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-edit |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-exists-message # Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: -zplg-exists-message |-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-show-report -zplg-unload -zplg-find-completions-of-plugin # Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: -zplg-find-completions-of-plugin `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-report -zplg-format-env # Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-format-functions # Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-format-options # Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: -zplg-format-options |-- -zplg-restore-extendedglob `-- -zplg-save-set-extendedglob Called by: -zplg-show-report -zplg-format-parameter # Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-get-completion-owner # Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: -zplg-clear-completions -zplg-get-completion-owner-uspl2col -zplg-show-completions -zplg-get-completion-owner-uspl2col # For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: -zplg-get-completion-owner-uspl2col |-- -zplg-get-completion-owner `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-cdisable -zplg-cenable -zplg-get-path # Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-cd -zplg-uninstall-completions -zplg-glance # Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: -zplg-glance |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-help # Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-list-bindkeys # Has 42 line(s). Calls functions: -zplg-list-bindkeys `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-list-compdef-replay # Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zplugin solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-ls # Has 19 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-module # Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zplugin' function defined in zplugin.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: -zplg-module `-- -zplg-build-module Called by: -zplg-build-module zplugin.zsh/zplugin -zplg-prepare-readlink # Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: -zplg-cdisable -zplg-cenable -zplg-clear-completions -zplg-show-completions -zplg-recall # Has 37 line(s). Calls functions: -zplg-recall `-- -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-recently # Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: -zplg-recently `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-restore-extendedglob # Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload -zplg-save-set-extendedglob # Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload -zplg-search-completions # While -zplg-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: -zplg-search-completions `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-self-update # Updates Zplugin code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zplugin.zsh/zplugin -zplg-show-all-reports # Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: -zplg-show-all-reports `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-show-completions # Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: -zplg-show-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-debug-report # Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: -zplg-show-debug-report `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-show-registered-plugins # Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: -zplg-show-registered-plugins |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-report # Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-all-reports -zplg-show-debug-report zplugin.zsh/zplugin -zplg-show-times # Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: -zplg-show-times `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin -zplg-show-zstatus # Shows Zplugin status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin -zplg-stress # Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: -zplg-stress |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-uncompile-plugin # Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: -zplg-uncompile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-compile-uncompile-all zplugin.zsh/zplugin -zplg-uninstall-completions # Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zplugin/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: -zplg-uninstall-completions |-- -zplg-get-path | |-- zplugin-side.zsh/-zplg-exists-physically | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-install.zsh/-zplg-forget-completion Called by: zplugin.zsh/zplugin -zplg-unload # 0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: -zplg-unload |-- -zplg-clear-report-for | `-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin.zsh/-zplg-clear-debug-report `-- zplugin.zsh/-zplg-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zplugin.zsh/-zplg-debug-unload zplugin.zsh/-zplg-run-task zplugin.zsh/zplugin -zplg-update-or-status # Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: -zplg-update-or-status |-- -zplg-at-eval |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version |-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-store-ices |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: -zplg-update-or-status-all zplugin.zsh/zplugin -zplg-update-or-status-all # Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: -zplg-update-or-status-all |-- -zplg-update-or-status | |-- -zplg-at-eval | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | |-- -zplg-update-or-status-snippet | | |-- -zplg-compute-ice | | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | | |-- zplugin-side.zsh/-zplg-shands-exp | | | |-- zplugin-side.zsh/-zplg-two-paths | | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | | `-- zplugin.zsh/-zplg-pack-ice | | `-- zplugin.zsh/-zplg-load-snippet | |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version | |-- zplugin-install.zsh/-zplg-setup-plugin-dir | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-store-ices | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin -zplg-update-or-status-snippet # Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: -zplg-update-or-status-snippet |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice `-- zplugin.zsh/-zplg-load-snippet Called by: -zplg-update-or-status-all -zplg-update-or-status compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: -zplg-compinit","title":"zplugin-autoload.zsh"},{"location":"zplugin-autoload.zsh/#zplugin-autoloadzsh1","text":"","title":"zplugin-autoload.zsh(1)"},{"location":"zplugin-autoload.zsh/#name","text":"zplugin-autoload.zsh - a shell script","title":"NAME"},{"location":"zplugin-autoload.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-autoload.zsh/#functions","text":"-zplg-any-to-uspl2 -zplg-at-eval -zplg-build-module -zplg-cd -zplg-cdisable -zplg-cenable -zplg-changes -zplg-check-comp-consistency -zplg-check-which-completions-are-enabled -zplg-check-which-completions-are-installed -zplg-clear-completions -zplg-clear-report-for -zplg-compiled -zplg-compile-uncompile-all -zplg-compinit -zplg-compute-ice -zplg-confirm -zplg-create -zplg-delete -zplg-diff-env-compute -zplg-diff-functions-compute -zplg-diff-options-compute -zplg-diff-parameter-compute -zplg-edit -zplg-exists-message -zplg-find-completions-of-plugin -zplg-format-env -zplg-format-functions -zplg-format-options -zplg-format-parameter -zplg-get-completion-owner -zplg-get-completion-owner-uspl2col -zplg-get-path -zplg-glance -zplg-help -zplg-list-bindkeys -zplg-list-compdef-replay -zplg-ls -zplg-module -zplg-prepare-readlink -zplg-recall -zplg-recently -zplg-restore-extendedglob -zplg-save-set-extendedglob -zplg-search-completions -zplg-self-update -zplg-show-all-reports -zplg-show-completions -zplg-show-debug-report -zplg-show-registered-plugins -zplg-show-report -zplg-show-times -zplg-show-zstatus -zplg-stress -zplg-uncompile-plugin -zplg-uninstall-completions -zplg-unload -zplg-update-or-status -zplg-update-or-status-all -zplg-update-or-status-snippet AUTOLOAD compinit","title":"FUNCTIONS"},{"location":"zplugin-autoload.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-autoload.zsh/#script_body","text":"Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-autoload.zsh/#-zplg-any-to-uspl2","text":"Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-clear-report-for -zplg-exists-message","title":"-zplg-any-to-uspl2"},{"location":"zplugin-autoload.zsh/#-zplg-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-update-or-status","title":"-zplg-at-eval"},{"location":"zplugin-autoload.zsh/#-zplg-build-module","text":"Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: -zplg-build-module `-- -zplg-module Uses feature(s): trap Called by: -zplg-module","title":"-zplg-build-module"},{"location":"zplugin-autoload.zsh/#-zplg-cd","text":"Jumps to plugin's directory (in Zplugin's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-cd `-- -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-cd"},{"location":"zplugin-autoload.zsh/#-zplg-cdisable","text":"Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: -zplg-cdisable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin","title":"-zplg-cdisable"},{"location":"zplugin-autoload.zsh/#-zplg-cenable","text":"Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: -zplg-cenable |-- -zplg-check-comp-consistency |-- -zplg-get-completion-owner-uspl2col | |-- -zplg-get-completion-owner | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- -zplg-prepare-readlink Called by: zplugin.zsh/zplugin","title":"-zplg-cenable"},{"location":"zplugin-autoload.zsh/#-zplg-changes","text":"Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: -zplg-changes |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-changes"},{"location":"zplugin-autoload.zsh/#-zplg-check-comp-consistency","text":"Zplugin creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-cdisable -zplg-cenable","title":"-zplg-check-comp-consistency"},{"location":"zplugin-autoload.zsh/#-zplg-check-which-completions-are-enabled","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-check-which-completions-are-enabled"},{"location":"zplugin-autoload.zsh/#-zplg-check-which-completions-are-installed","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-check-which-completions-are-installed"},{"location":"zplugin-autoload.zsh/#-zplg-clear-completions","text":"Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: -zplg-clear-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-clear-completions"},{"location":"zplugin-autoload.zsh/#-zplg-clear-report-for","text":"Clears all report data for given user/plugin. This is done by resetting all related global ZPLG_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: -zplg-clear-report-for `-- -zplg-any-to-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-unload zplugin.zsh/-zplg-clear-debug-report","title":"-zplg-clear-report-for"},{"location":"zplugin-autoload.zsh/#-zplg-compiled","text":"Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: -zplg-compiled |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-compiled"},{"location":"zplugin-autoload.zsh/#-zplg-compile-uncompile-all","text":"Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: -zplg-compile-uncompile-all |-- -zplg-uncompile-plugin | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-compile-uncompile-all"},{"location":"zplugin-autoload.zsh/#-zplg-compinit","text":"User-exposed `compinit' frontend which first ensures that all completions managed by Zplugin are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zplugin's completions. No arguments. Has 23 line(s). Calls functions: -zplg-compinit |-- compinit `-- zplugin-install.zsh/-zplg-forget-completion Uses feature(s): autoload , unfunction Called by: zplugin.zsh/zplugin","title":"-zplg-compinit"},{"location":"zplugin-autoload.zsh/#-zplg-compute-ice","text":"Computes ZPLG_ICE array (default, it can be specified via $3) from a) input ZPLG_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZPLG_ICE[svn] is not set). Can also pack resulting ices into ZPLG_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZPLG_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZPLG_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Called by: -zplg-recall -zplg-update-or-status-snippet -zplg-update-or-status","title":"-zplg-compute-ice"},{"location":"zplugin-autoload.zsh/#-zplg-confirm","text":"Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: -zplg-delete","title":"-zplg-confirm"},{"location":"zplugin-autoload.zsh/#-zplg-create","text":"Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: -zplg-create |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-create"},{"location":"zplugin-autoload.zsh/#-zplg-delete","text":"Deletes plugin's or snippet's directory (in Zplugin's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: -zplg-delete |-- -zplg-confirm |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-delete"},{"location":"zplugin-autoload.zsh/#-zplg-diff-env-compute","text":"Computes ZPLG_PATH, ZPLG_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by -zplg-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-env-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-functions-compute","text":"Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by -zplg-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-functions-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-options-compute","text":"Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by -zplg-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-options-compute"},{"location":"zplugin-autoload.zsh/#-zplg-diff-parameter-compute","text":"Computes ZPLG_PARAMETERS_PRE, ZPLG_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by -zplg-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: -zplg-show-report -zplg-unload","title":"-zplg-diff-parameter-compute"},{"location":"zplugin-autoload.zsh/#-zplg-edit","text":"Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: -zplg-edit |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-edit"},{"location":"zplugin-autoload.zsh/#-zplg-exists-message","text":"Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: -zplg-exists-message |-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-show-report -zplg-unload","title":"-zplg-exists-message"},{"location":"zplugin-autoload.zsh/#-zplg-find-completions-of-plugin","text":"Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: -zplg-find-completions-of-plugin `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-report","title":"-zplg-find-completions-of-plugin"},{"location":"zplugin-autoload.zsh/#-zplg-format-env","text":"Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-env"},{"location":"zplugin-autoload.zsh/#-zplg-format-functions","text":"Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-functions"},{"location":"zplugin-autoload.zsh/#-zplg-format-options","text":"Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: -zplg-format-options |-- -zplg-restore-extendedglob `-- -zplg-save-set-extendedglob Called by: -zplg-show-report","title":"-zplg-format-options"},{"location":"zplugin-autoload.zsh/#-zplg-format-parameter","text":"Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: -zplg-show-report","title":"-zplg-format-parameter"},{"location":"zplugin-autoload.zsh/#-zplg-get-completion-owner","text":"Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: -zplg-clear-completions -zplg-get-completion-owner-uspl2col -zplg-show-completions","title":"-zplg-get-completion-owner"},{"location":"zplugin-autoload.zsh/#-zplg-get-completion-owner-uspl2col","text":"For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: -zplg-get-completion-owner-uspl2col |-- -zplg-get-completion-owner `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: -zplg-cdisable -zplg-cenable","title":"-zplg-get-completion-owner-uspl2col"},{"location":"zplugin-autoload.zsh/#-zplg-get-path","text":"Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: -zplg-get-path |-- zplugin-side.zsh/-zplg-exists-physically |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-cd -zplg-uninstall-completions","title":"-zplg-get-path"},{"location":"zplugin-autoload.zsh/#-zplg-glance","text":"Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: -zplg-glance |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-glance"},{"location":"zplugin-autoload.zsh/#-zplg-help","text":"Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-help"},{"location":"zplugin-autoload.zsh/#-zplg-list-bindkeys","text":"Has 42 line(s). Calls functions: -zplg-list-bindkeys `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-list-bindkeys"},{"location":"zplugin-autoload.zsh/#-zplg-list-compdef-replay","text":"Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zplugin solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-list-compdef-replay"},{"location":"zplugin-autoload.zsh/#-zplg-ls","text":"Has 19 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-ls"},{"location":"zplugin-autoload.zsh/#-zplg-module","text":"Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zplugin' function defined in zplugin.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: -zplg-module `-- -zplg-build-module Called by: -zplg-build-module zplugin.zsh/zplugin","title":"-zplg-module"},{"location":"zplugin-autoload.zsh/#-zplg-prepare-readlink","text":"Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: -zplg-cdisable -zplg-cenable -zplg-clear-completions -zplg-show-completions","title":"-zplg-prepare-readlink"},{"location":"zplugin-autoload.zsh/#-zplg-recall","text":"Has 37 line(s). Calls functions: -zplg-recall `-- -zplg-compute-ice |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-shands-exp |-- zplugin-side.zsh/-zplg-two-paths |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-recall"},{"location":"zplugin-autoload.zsh/#-zplg-recently","text":"Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: -zplg-recently `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-recently"},{"location":"zplugin-autoload.zsh/#-zplg-restore-extendedglob","text":"Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload","title":"-zplg-restore-extendedglob"},{"location":"zplugin-autoload.zsh/#-zplg-save-set-extendedglob","text":"Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: -zplg-format-options -zplg-show-registered-plugins -zplg-unload","title":"-zplg-save-set-extendedglob"},{"location":"zplugin-autoload.zsh/#-zplg-search-completions","text":"While -zplg-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: -zplg-search-completions `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-search-completions"},{"location":"zplugin-autoload.zsh/#-zplg-self-update","text":"Updates Zplugin code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zplugin.zsh/zplugin","title":"-zplg-self-update"},{"location":"zplugin-autoload.zsh/#-zplg-show-all-reports","text":"Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: -zplg-show-all-reports `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-show-all-reports"},{"location":"zplugin-autoload.zsh/#-zplg-show-completions","text":"Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: -zplg-show-completions |-- -zplg-get-completion-owner |-- -zplg-prepare-readlink `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-completions"},{"location":"zplugin-autoload.zsh/#-zplg-show-debug-report","text":"Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: -zplg-show-debug-report `-- -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-show-debug-report"},{"location":"zplugin-autoload.zsh/#-zplg-show-registered-plugins","text":"Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: -zplg-show-registered-plugins |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-registered-plugins"},{"location":"zplugin-autoload.zsh/#-zplg-show-report","text":"Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: -zplg-show-report |-- -zplg-check-which-completions-are-enabled |-- -zplg-check-which-completions-are-installed |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-find-completions-of-plugin | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-format-env |-- -zplg-format-functions |-- -zplg-format-options | |-- -zplg-restore-extendedglob | `-- -zplg-save-set-extendedglob |-- -zplg-format-parameter `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-show-all-reports -zplg-show-debug-report zplugin.zsh/zplugin","title":"-zplg-show-report"},{"location":"zplugin-autoload.zsh/#-zplg-show-times","text":"Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: -zplg-show-times `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 Called by: zplugin.zsh/zplugin","title":"-zplg-show-times"},{"location":"zplugin-autoload.zsh/#-zplg-show-zstatus","text":"Shows Zplugin status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zplugin.zsh/zplugin","title":"-zplg-show-zstatus"},{"location":"zplugin-autoload.zsh/#-zplg-stress","text":"Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: -zplg-stress |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-stress"},{"location":"zplugin-autoload.zsh/#-zplg-uncompile-plugin","text":"Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: -zplg-uncompile-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-compile-uncompile-all zplugin.zsh/zplugin","title":"-zplg-uncompile-plugin"},{"location":"zplugin-autoload.zsh/#-zplg-uninstall-completions","text":"Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zplugin/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: -zplg-uninstall-completions |-- -zplg-get-path | |-- zplugin-side.zsh/-zplg-exists-physically | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin-install.zsh/-zplg-forget-completion Called by: zplugin.zsh/zplugin","title":"-zplg-uninstall-completions"},{"location":"zplugin-autoload.zsh/#-zplg-unload","text":"0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: -zplg-unload |-- -zplg-clear-report-for | `-- -zplg-any-to-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-diff-env-compute |-- -zplg-diff-functions-compute |-- -zplg-diff-options-compute |-- -zplg-diff-parameter-compute |-- -zplg-exists-message | |-- -zplg-any-to-uspl2 | | `-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- -zplg-restore-extendedglob |-- -zplg-save-set-extendedglob |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin.zsh/-zplg-clear-debug-report `-- zplugin.zsh/-zplg-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zplugin.zsh/-zplg-debug-unload zplugin.zsh/-zplg-run-task zplugin.zsh/zplugin","title":"-zplg-unload"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status","text":"Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: -zplg-update-or-status |-- -zplg-at-eval |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version |-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message |-- zplugin-side.zsh/-zplg-store-ices |-- zplugin-side.zsh/-zplg-two-paths `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: -zplg-update-or-status-all zplugin.zsh/zplugin","title":"-zplg-update-or-status"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status-all","text":"Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: -zplg-update-or-status-all |-- -zplg-update-or-status | |-- -zplg-at-eval | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | |-- -zplg-update-or-status-snippet | | |-- -zplg-compute-ice | | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | | |-- zplugin-side.zsh/-zplg-shands-exp | | | |-- zplugin-side.zsh/-zplg-two-paths | | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | | `-- zplugin.zsh/-zplg-pack-ice | | `-- zplugin.zsh/-zplg-load-snippet | |-- zplugin-install.zsh/-zplg-get-latest-gh-r-version | |-- zplugin-install.zsh/-zplg-setup-plugin-dir | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-store-ices | |-- zplugin-side.zsh/-zplg-two-paths | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-update-or-status-snippet | |-- -zplg-compute-ice | | |-- zplugin-side.zsh/-zplg-exists-physically-message | | |-- zplugin-side.zsh/-zplg-shands-exp | | |-- zplugin-side.zsh/-zplg-two-paths | | |-- zplugin.zsh/-zplg-any-to-user-plugin | | `-- zplugin.zsh/-zplg-pack-ice | `-- zplugin.zsh/-zplg-load-snippet |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin.zsh/zplugin","title":"-zplg-update-or-status-all"},{"location":"zplugin-autoload.zsh/#-zplg-update-or-status-snippet","text":"Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: -zplg-update-or-status-snippet |-- -zplg-compute-ice | |-- zplugin-side.zsh/-zplg-exists-physically-message | |-- zplugin-side.zsh/-zplg-shands-exp | |-- zplugin-side.zsh/-zplg-two-paths | |-- zplugin.zsh/-zplg-any-to-user-plugin | `-- zplugin.zsh/-zplg-pack-ice `-- zplugin.zsh/-zplg-load-snippet Called by: -zplg-update-or-status-all -zplg-update-or-status","title":"-zplg-update-or-status-snippet"},{"location":"zplugin-autoload.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: -zplg-compinit","title":"compinit"},{"location":"zplugin-install.zsh/","text":"zplugin-install.zsh(1) # NAME # zplugin-install.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-at-eval -zplg-compile-plugin -zplg-download-file-stdout -zplg-download-snippet -zplg-forget-completion -zplg-get-latest-gh-r-version -zplg-handle-binary-file -zplg-install-completions -zplg-mirror-using-svn -zplg-setup-plugin-dir DETAILS # Script Body # Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source -zplg-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-download-snippet -zplg-compile-plugin # Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: -zplg-compile-plugin |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): eval , zcompile Called by: -zplg-setup-plugin-dir zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin.zsh/zplugin -zplg-download-file-stdout # Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: -zplg-download-file-stdout Uses feature(s): type Called by: -zplg-download-snippet -zplg-setup-plugin-dir -zplg-download-snippet # Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: -zplg-download-snippet |-- -zplg-at-eval |-- -zplg-download-file-stdout |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-mirror-using-svn `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval , zcompile Called by: zplugin.zsh/-zplg-load-snippet -zplg-forget-completion # Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-install-completions zplugin-autoload.zsh/-zplg-compinit zplugin-autoload.zsh/-zplg-uninstall-completions zplugin.zsh/zplugin -zplg-get-latest-gh-r-version # Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: -zplg-get-latest-gh-r-version `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-update-or-status -zplg-handle-binary-file # If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-setup-plugin-dir -zplg-install-completions # Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: -zplg-install-completions |-- -zplg-forget-completion |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-download-snippet -zplg-setup-plugin-dir zplugin.zsh/zplugin -zplg-mirror-using-svn # Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: -zplg-download-snippet -zplg-setup-plugin-dir # Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: -zplg-setup-plugin-dir |-- -zplg-compile-plugin | |-- zplugin-side.zsh/-zplg-first | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-download-file-stdout |-- -zplg-handle-binary-file |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin.zsh/-zplg-load","title":"zplugin-install.zsh"},{"location":"zplugin-install.zsh/#zplugin-installzsh1","text":"","title":"zplugin-install.zsh(1)"},{"location":"zplugin-install.zsh/#name","text":"zplugin-install.zsh - a shell script","title":"NAME"},{"location":"zplugin-install.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-install.zsh/#functions","text":"-zplg-at-eval -zplg-compile-plugin -zplg-download-file-stdout -zplg-download-snippet -zplg-forget-completion -zplg-get-latest-gh-r-version -zplg-handle-binary-file -zplg-install-completions -zplg-mirror-using-svn -zplg-setup-plugin-dir","title":"FUNCTIONS"},{"location":"zplugin-install.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-install.zsh/#script_body","text":"Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-install.zsh/#-zplg-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-download-snippet","title":"-zplg-at-eval"},{"location":"zplugin-install.zsh/#-zplg-compile-plugin","text":"Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: -zplg-compile-plugin |-- zplugin-side.zsh/-zplg-first `-- zplugin.zsh/-zplg-any-to-user-plugin Uses feature(s): eval , zcompile Called by: -zplg-setup-plugin-dir zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin.zsh/zplugin","title":"-zplg-compile-plugin"},{"location":"zplugin-install.zsh/#-zplg-download-file-stdout","text":"Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: -zplg-download-file-stdout Uses feature(s): type Called by: -zplg-download-snippet -zplg-setup-plugin-dir","title":"-zplg-download-file-stdout"},{"location":"zplugin-install.zsh/#-zplg-download-snippet","text":"Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: -zplg-download-snippet |-- -zplg-at-eval |-- -zplg-download-file-stdout |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-mirror-using-svn `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval , zcompile Called by: zplugin.zsh/-zplg-load-snippet","title":"-zplg-download-snippet"},{"location":"zplugin-install.zsh/#-zplg-forget-completion","text":"Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-install-completions zplugin-autoload.zsh/-zplg-compinit zplugin-autoload.zsh/-zplg-uninstall-completions zplugin.zsh/zplugin","title":"-zplg-forget-completion"},{"location":"zplugin-install.zsh/#-zplg-get-latest-gh-r-version","text":"Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: -zplg-get-latest-gh-r-version `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-update-or-status","title":"-zplg-get-latest-gh-r-version"},{"location":"zplugin-install.zsh/#-zplg-handle-binary-file","text":"If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-setup-plugin-dir","title":"-zplg-handle-binary-file"},{"location":"zplugin-install.zsh/#-zplg-install-completions","text":"Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: -zplg-install-completions |-- -zplg-forget-completion |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 |-- zplugin-side.zsh/-zplg-exists-physically-message `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-download-snippet -zplg-setup-plugin-dir zplugin.zsh/zplugin","title":"-zplg-install-completions"},{"location":"zplugin-install.zsh/#-zplg-mirror-using-svn","text":"Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: -zplg-download-snippet","title":"-zplg-mirror-using-svn"},{"location":"zplugin-install.zsh/#-zplg-setup-plugin-dir","text":"Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: -zplg-setup-plugin-dir |-- -zplg-compile-plugin | |-- zplugin-side.zsh/-zplg-first | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-download-file-stdout |-- -zplg-handle-binary-file |-- -zplg-install-completions | |-- -zplg-forget-completion | |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 | |-- zplugin-side.zsh/-zplg-exists-physically-message | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- zplugin-side.zsh/-zplg-any-colorify-as-uspl2 `-- zplugin-side.zsh/-zplg-store-ices Uses feature(s): eval Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin.zsh/-zplg-load","title":"-zplg-setup-plugin-dir"},{"location":"zplugin-side.zsh/","text":"zplugin-side.zsh(1) # NAME # zplugin-side.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # -zplg-any-colorify-as-uspl2 -zplg-exists-physically -zplg-exists-physically-message -zplg-first -zplg-get-plg-dir -zplg-shands-exp -zplg-store-ices -zplg-two-paths DETAILS # Script Body # Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). -zplg-any-colorify-as-uspl2 # Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: -zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-clear-completions zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-exists-message zplugin-autoload.zsh/-zplg-get-completion-owner-uspl2col zplugin-autoload.zsh/-zplg-list-bindkeys zplugin-autoload.zsh/-zplg-recently zplugin-autoload.zsh/-zplg-search-completions zplugin-autoload.zsh/-zplg-show-completions zplugin-autoload.zsh/-zplg-show-registered-plugins zplugin-autoload.zsh/-zplg-show-times zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions zplugin-install.zsh/-zplg-setup-plugin-dir -zplg-exists-physically # Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: -zplg-exists-physically |-- -zplg-shands-exp `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-get-path -zplg-exists-physically-message # Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: -zplg-exists-physically-message |-- -zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-exists-physically | |-- -zplg-shands-exp | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- -zplg-shands-exp Called by: zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions -zplg-first # Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. -zplg-load-plugin() has similar code parts and doesn't call -zplg-first() \u2013 for performance. Obscure matching is done in -zplg-find-other-matches, here and in -zplg-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: -zplg-first |-- -zplg-get-plg-dir |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-find-other-matches Called by: zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-install.zsh/-zplg-compile-plugin -zplg-get-plg-dir # Has 9 line(s). Doesn't call other functions. Called by: -zplg-first -zplg-shands-exp # Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: -zplg-exists-physically-message -zplg-exists-physically zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path -zplg-store-ices # Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-download-snippet zplugin-install.zsh/-zplg-setup-plugin-dir -zplg-two-paths # Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-update-or-status","title":"zplugin-side.zsh"},{"location":"zplugin-side.zsh/#zplugin-sidezsh1","text":"","title":"zplugin-side.zsh(1)"},{"location":"zplugin-side.zsh/#name","text":"zplugin-side.zsh - a shell script","title":"NAME"},{"location":"zplugin-side.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-side.zsh/#functions","text":"-zplg-any-colorify-as-uspl2 -zplg-exists-physically -zplg-exists-physically-message -zplg-first -zplg-get-plg-dir -zplg-shands-exp -zplg-store-ices -zplg-two-paths","title":"FUNCTIONS"},{"location":"zplugin-side.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-side.zsh/#script_body","text":"Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.).","title":"Script Body"},{"location":"zplugin-side.zsh/#-zplg-any-colorify-as-uspl2","text":"Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: -zplg-any-colorify-as-uspl2 `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-clear-completions zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-exists-message zplugin-autoload.zsh/-zplg-get-completion-owner-uspl2col zplugin-autoload.zsh/-zplg-list-bindkeys zplugin-autoload.zsh/-zplg-recently zplugin-autoload.zsh/-zplg-search-completions zplugin-autoload.zsh/-zplg-show-completions zplugin-autoload.zsh/-zplg-show-registered-plugins zplugin-autoload.zsh/-zplg-show-times zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions zplugin-install.zsh/-zplg-setup-plugin-dir","title":"-zplg-any-colorify-as-uspl2"},{"location":"zplugin-side.zsh/#-zplg-exists-physically","text":"Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: -zplg-exists-physically |-- -zplg-shands-exp `-- zplugin.zsh/-zplg-any-to-user-plugin Called by: -zplg-exists-physically-message zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-get-path","title":"-zplg-exists-physically"},{"location":"zplugin-side.zsh/#-zplg-exists-physically-message","text":"Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: -zplg-exists-physically-message |-- -zplg-any-colorify-as-uspl2 | `-- zplugin.zsh/-zplg-any-to-user-plugin |-- -zplg-exists-physically | |-- -zplg-shands-exp | `-- zplugin.zsh/-zplg-any-to-user-plugin `-- -zplg-shands-exp Called by: zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-install-completions","title":"-zplg-exists-physically-message"},{"location":"zplugin-side.zsh/#-zplg-first","text":"Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. -zplg-load-plugin() has similar code parts and doesn't call -zplg-first() \u2013 for performance. Obscure matching is done in -zplg-find-other-matches, here and in -zplg-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: -zplg-first |-- -zplg-get-plg-dir |-- zplugin.zsh/-zplg-any-to-user-plugin `-- zplugin.zsh/-zplg-find-other-matches Called by: zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-stress zplugin-install.zsh/-zplg-compile-plugin","title":"-zplg-first"},{"location":"zplugin-side.zsh/#-zplg-get-plg-dir","text":"Has 9 line(s). Doesn't call other functions. Called by: -zplg-first","title":"-zplg-get-plg-dir"},{"location":"zplugin-side.zsh/#-zplg-shands-exp","text":"Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: -zplg-exists-physically-message -zplg-exists-physically zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path","title":"-zplg-shands-exp"},{"location":"zplugin-side.zsh/#-zplg-store-ices","text":"Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-download-snippet zplugin-install.zsh/-zplg-setup-plugin-dir","title":"-zplg-store-ices"},{"location":"zplugin-side.zsh/#-zplg-two-paths","text":"Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-update-or-status","title":"-zplg-two-paths"},{"location":"zplugin.zsh/","text":"zplugin.zsh(1) # NAME # zplugin.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # pmodload zpcdclear zpcdreplay zpcompdef zpcompinit -zplg-add-report -zplg-any-to-user-plugin -zplg-clear-debug-report -zplg-compdef-clear -zplg-compdef-replay -zplg-debug-start -zplg-debug-stop -zplg-debug-unload -zplg-deploy-message -zplg-diff -zplg-diff-env -zplg-diff-functions -zplg-diff-options -zplg-diff-parameter -zplg-find-other-matches -zplg-ice -zplg-load -zplg-load-plugin -zplg-load-snippet -zplg-pack-ice -zplg-prepare-home -zplg-register-plugin @zplg-register-z-plugin --zplg-reload-and-run -zplg-run-task -zplg-service --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef -zplg-shadow-off -zplg-shadow-on --zplg-shadow-zle --zplg-shadow-zstyle -zplg-submit-turbo -zplg-unregister-plugin -zplg-wrap-track-functions zplugin -zplugin_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK -zplg-scheduler DETAILS # Script Body # Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- -zplg-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX pmodload # Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdclear # A wrapper for `zplugin cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- -zplg-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdreplay # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zplugin cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- -zplg-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompdef # Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zplugin cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompinit # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZPLGM[ZCOMPDUMP_PATH] and ZPLGM[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-add-report # Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: -zplg-load-plugin --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef --zplg-shadow-zle --zplg-shadow-zstyle -zplg-any-to-user-plugin # Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: -zplg-load -zplg-unregister-plugin zplugin-autoload.zsh/-zplg-any-to-uspl2 zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-find-completions-of-plugin zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-show-report zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-compile-plugin zplugin-install.zsh/-zplg-get-latest-gh-r-version zplugin-install.zsh/-zplg-install-completions zplugin-side.zsh/-zplg-any-colorify-as-uspl2 zplugin-side.zsh/-zplg-exists-physically zplugin-side.zsh/-zplg-first -zplg-clear-debug-report # Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: -zplg-clear-debug-report `-- zplugin-autoload.zsh/-zplg-clear-report-for Called by: zplugin zplugin-autoload.zsh/-zplg-unload -zplg-compdef-clear # Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zplugin -zplg-compdef-replay # Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zplugin -zplg-debug-start # Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: -zplg-debug-start |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-on Called by: zplugin -zplg-debug-stop # Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: -zplg-debug-stop |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-off Called by: zplugin -zplg-debug-unload # Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: -zplg-debug-unload `-- zplugin-autoload.zsh/-zplg-unload Called by: zplugin -zplg-deploy-message # Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: -zplg-load-snippet -zplg-load -zplg-diff # Performs diff actions of all types Has 4 line(s). Calls functions: -zplg-diff |-- -zplg-diff-env |-- -zplg-diff-functions |-- -zplg-diff-options `-- -zplg-diff-parameter Called by: -zplg-debug-start -zplg-debug-stop -zplg-load-plugin -zplg-diff-env # Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-load-plugin -zplg-diff-functions # Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-diff-options # Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-diff-parameter # Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-find-other-matches # Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: -zplg-load-plugin zplugin-side.zsh/-zplg-first -zplg-ice # Parses ICE specification (`zplg ice' subcommand), puts the result into ZPLG_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zplugin Environment variables used: ZPFX -zplg-load # Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: -zplg-load |-- -zplg-any-to-user-plugin |-- -zplg-deploy-message |-- -zplg-load-plugin | |-- -zplg-add-report | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | |-- -zplg-diff-env | |-- -zplg-find-other-matches | |-- -zplg-shadow-off | |-- -zplg-shadow-on | `-- -zplg-wrap-track-functions |-- -zplg-pack-ice |-- -zplg-register-plugin `-- zplugin-install.zsh/-zplg-setup-plugin-dir Uses feature(s): eval , source , zle Called by: -zplg-run-task -zplg-service zplugin -zplg-load-plugin # Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: -zplg-load-plugin |-- -zplg-add-report |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter |-- -zplg-diff-env |-- -zplg-find-other-matches |-- -zplg-shadow-off |-- -zplg-shadow-on `-- -zplg-wrap-track-functions Uses feature(s): eval , source , zle Called by: -zplg-load -zplg-load-snippet # Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload -zplg-run-task -zplg-service zplugin zplugin-autoload.zsh/-zplg-update-or-status-snippet -zplg-pack-ice # Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zplugin update ...' Has 3 line(s). Doesn't call other functions. Called by: -zplg-load-snippet -zplg-load zplugin-autoload.zsh/-zplg-compute-ice -zplg-prepare-home # Creates all directories needed by Zplugin, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX -zplg-register-plugin # Adds the plugin to ZPLG_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: -zplg-load @zplg-register-z-plugin # Registers the z-plugin inside Zplugin \u2013 i.e. an Zplugin extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-reload-and-run # Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls --zplg-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-run-task # A backend, worker function of -zplg-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZPLGM[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): eval , source , zle , zpty Called by: -zplg-scheduler -zplg-scheduler # Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive -zplg-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: -zplg-scheduler |-- add-zsh-hook `-- -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-service # Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: -zplg-service |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-alias # Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: --zplg-shadow-alias `-- -zplg-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-autoload # Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: --zplg-shadow-autoload `-- -zplg-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-bindkey # Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: --zplg-shadow-bindkey |-- is-at-least `-- -zplg-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-compdef # Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: --zplg-shadow-compdef `-- -zplg-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-shadow-off # Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-debug-stop -zplg-load-plugin -zplg-shadow-on # Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: -zplg-debug-start -zplg-load-plugin --zplg-shadow-zle # Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: --zplg-shadow-zle `-- -zplg-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). --zplg-shadow-zstyle # Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: --zplg-shadow-zstyle `-- -zplg-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplg-submit-turbo # If `zplugin load`, `zplugin light` or `zplugin snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that -zplg-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zplugin -zplg-unregister-plugin # Removes the plugin from ZPLG_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: -zplg-unregister-plugin `-- -zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-unload -zplg-wrap-track-functions # Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-load-plugin -zplg-load-snippet zplugin # Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zplugin |-- compinit |-- -zplg-clear-debug-report | `-- zplugin-autoload.zsh/-zplg-clear-report-for |-- -zplg-compdef-clear |-- -zplg-compdef-replay |-- -zplg-debug-start | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-on |-- -zplg-debug-stop | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-off |-- -zplg-debug-unload | `-- zplugin-autoload.zsh/-zplg-unload |-- -zplg-ice |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet |-- -zplg-submit-turbo |-- zplugin-autoload.zsh/-zplg-cdisable |-- zplugin-autoload.zsh/-zplg-cenable |-- zplugin-autoload.zsh/-zplg-clear-completions |-- zplugin-autoload.zsh/-zplg-compiled |-- zplugin-autoload.zsh/-zplg-compile-uncompile-all |-- zplugin-autoload.zsh/-zplg-compinit |-- zplugin-autoload.zsh/-zplg-help |-- zplugin-autoload.zsh/-zplg-list-bindkeys |-- zplugin-autoload.zsh/-zplg-list-compdef-replay |-- zplugin-autoload.zsh/-zplg-ls |-- zplugin-autoload.zsh/-zplg-module |-- zplugin-autoload.zsh/-zplg-recently |-- zplugin-autoload.zsh/-zplg-search-completions |-- zplugin-autoload.zsh/-zplg-self-update |-- zplugin-autoload.zsh/-zplg-show-all-reports |-- zplugin-autoload.zsh/-zplg-show-completions |-- zplugin-autoload.zsh/-zplg-show-debug-report |-- zplugin-autoload.zsh/-zplg-show-registered-plugins |-- zplugin-autoload.zsh/-zplg-show-report |-- zplugin-autoload.zsh/-zplg-show-times |-- zplugin-autoload.zsh/-zplg-show-zstatus |-- zplugin-autoload.zsh/-zplg-uncompile-plugin |-- zplugin-autoload.zsh/-zplg-uninstall-completions |-- zplugin-autoload.zsh/-zplg-unload |-- zplugin-autoload.zsh/-zplg-update-or-status |-- zplugin-autoload.zsh/-zplg-update-or-status-all |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-install.zsh/-zplg-forget-completion `-- zplugin-install.zsh/-zplg-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zplugin_scheduler_add_sh # Copies task into ZPLG_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). add-zsh-hook # Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body -zplg-scheduler compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zplugin is-at-least # Has 56 line(s). Doesn't call other functions. Called by: Script-Body --zplg-shadow-bindkey","title":"zplugin.zsh"},{"location":"zplugin.zsh/#zpluginzsh1","text":"","title":"zplugin.zsh(1)"},{"location":"zplugin.zsh/#name","text":"zplugin.zsh - a shell script","title":"NAME"},{"location":"zplugin.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin.zsh/#functions","text":"pmodload zpcdclear zpcdreplay zpcompdef zpcompinit -zplg-add-report -zplg-any-to-user-plugin -zplg-clear-debug-report -zplg-compdef-clear -zplg-compdef-replay -zplg-debug-start -zplg-debug-stop -zplg-debug-unload -zplg-deploy-message -zplg-diff -zplg-diff-env -zplg-diff-functions -zplg-diff-options -zplg-diff-parameter -zplg-find-other-matches -zplg-ice -zplg-load -zplg-load-plugin -zplg-load-snippet -zplg-pack-ice -zplg-prepare-home -zplg-register-plugin @zplg-register-z-plugin --zplg-reload-and-run -zplg-run-task -zplg-service --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef -zplg-shadow-off -zplg-shadow-on --zplg-shadow-zle --zplg-shadow-zstyle -zplg-submit-turbo -zplg-unregister-plugin -zplg-wrap-track-functions zplugin -zplugin_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK -zplg-scheduler","title":"FUNCTIONS"},{"location":"zplugin.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin.zsh/#script_body","text":"Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- -zplg-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX","title":"Script Body"},{"location":"zplugin.zsh/#pmodload","text":"Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"pmodload"},{"location":"zplugin.zsh/#zpcdclear","text":"A wrapper for `zplugin cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- -zplg-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdclear"},{"location":"zplugin.zsh/#zpcdreplay","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zplugin cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- -zplg-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdreplay"},{"location":"zplugin.zsh/#zpcompdef","text":"Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zplugin cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompdef"},{"location":"zplugin.zsh/#zpcompinit","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZPLGM[ZCOMPDUMP_PATH] and ZPLGM[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompinit"},{"location":"zplugin.zsh/#-zplg-add-report","text":"Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: -zplg-load-plugin --zplg-shadow-alias --zplg-shadow-autoload --zplg-shadow-bindkey --zplg-shadow-compdef --zplg-shadow-zle --zplg-shadow-zstyle","title":"-zplg-add-report"},{"location":"zplugin.zsh/#-zplg-any-to-user-plugin","text":"Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: -zplg-load -zplg-unregister-plugin zplugin-autoload.zsh/-zplg-any-to-uspl2 zplugin-autoload.zsh/-zplg-changes zplugin-autoload.zsh/-zplg-compiled zplugin-autoload.zsh/-zplg-compile-uncompile-all zplugin-autoload.zsh/-zplg-compute-ice zplugin-autoload.zsh/-zplg-create zplugin-autoload.zsh/-zplg-delete zplugin-autoload.zsh/-zplg-edit zplugin-autoload.zsh/-zplg-find-completions-of-plugin zplugin-autoload.zsh/-zplg-get-path zplugin-autoload.zsh/-zplg-glance zplugin-autoload.zsh/-zplg-show-report zplugin-autoload.zsh/-zplg-stress zplugin-autoload.zsh/-zplg-uncompile-plugin zplugin-autoload.zsh/-zplg-unload zplugin-autoload.zsh/-zplg-update-or-status-all zplugin-autoload.zsh/-zplg-update-or-status zplugin-install.zsh/-zplg-compile-plugin zplugin-install.zsh/-zplg-get-latest-gh-r-version zplugin-install.zsh/-zplg-install-completions zplugin-side.zsh/-zplg-any-colorify-as-uspl2 zplugin-side.zsh/-zplg-exists-physically zplugin-side.zsh/-zplg-first","title":"-zplg-any-to-user-plugin"},{"location":"zplugin.zsh/#-zplg-clear-debug-report","text":"Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: -zplg-clear-debug-report `-- zplugin-autoload.zsh/-zplg-clear-report-for Called by: zplugin zplugin-autoload.zsh/-zplg-unload","title":"-zplg-clear-debug-report"},{"location":"zplugin.zsh/#-zplg-compdef-clear","text":"Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zplugin","title":"-zplg-compdef-clear"},{"location":"zplugin.zsh/#-zplg-compdef-replay","text":"Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zplugin","title":"-zplg-compdef-replay"},{"location":"zplugin.zsh/#-zplg-debug-start","text":"Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: -zplg-debug-start |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-on Called by: zplugin","title":"-zplg-debug-start"},{"location":"zplugin.zsh/#-zplg-debug-stop","text":"Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: -zplg-debug-stop |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter `-- -zplg-shadow-off Called by: zplugin","title":"-zplg-debug-stop"},{"location":"zplugin.zsh/#-zplg-debug-unload","text":"Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: -zplg-debug-unload `-- zplugin-autoload.zsh/-zplg-unload Called by: zplugin","title":"-zplg-debug-unload"},{"location":"zplugin.zsh/#-zplg-deploy-message","text":"Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: -zplg-load-snippet -zplg-load","title":"-zplg-deploy-message"},{"location":"zplugin.zsh/#-zplg-diff","text":"Performs diff actions of all types Has 4 line(s). Calls functions: -zplg-diff |-- -zplg-diff-env |-- -zplg-diff-functions |-- -zplg-diff-options `-- -zplg-diff-parameter Called by: -zplg-debug-start -zplg-debug-stop -zplg-load-plugin","title":"-zplg-diff"},{"location":"zplugin.zsh/#-zplg-diff-env","text":"Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: -zplg-diff -zplg-load-plugin","title":"-zplg-diff-env"},{"location":"zplugin.zsh/#-zplg-diff-functions","text":"Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-functions"},{"location":"zplugin.zsh/#-zplg-diff-options","text":"Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-options"},{"location":"zplugin.zsh/#-zplg-diff-parameter","text":"Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: -zplg-diff","title":"-zplg-diff-parameter"},{"location":"zplugin.zsh/#-zplg-find-other-matches","text":"Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: -zplg-load-plugin zplugin-side.zsh/-zplg-first","title":"-zplg-find-other-matches"},{"location":"zplugin.zsh/#-zplg-ice","text":"Parses ICE specification (`zplg ice' subcommand), puts the result into ZPLG_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zplugin Environment variables used: ZPFX","title":"-zplg-ice"},{"location":"zplugin.zsh/#-zplg-load","text":"Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: -zplg-load |-- -zplg-any-to-user-plugin |-- -zplg-deploy-message |-- -zplg-load-plugin | |-- -zplg-add-report | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | |-- -zplg-diff-env | |-- -zplg-find-other-matches | |-- -zplg-shadow-off | |-- -zplg-shadow-on | `-- -zplg-wrap-track-functions |-- -zplg-pack-ice |-- -zplg-register-plugin `-- zplugin-install.zsh/-zplg-setup-plugin-dir Uses feature(s): eval , source , zle Called by: -zplg-run-task -zplg-service zplugin","title":"-zplg-load"},{"location":"zplugin.zsh/#-zplg-load-plugin","text":"Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: -zplg-load-plugin |-- -zplg-add-report |-- -zplg-diff | |-- -zplg-diff-env | |-- -zplg-diff-functions | |-- -zplg-diff-options | `-- -zplg-diff-parameter |-- -zplg-diff-env |-- -zplg-find-other-matches |-- -zplg-shadow-off |-- -zplg-shadow-on `-- -zplg-wrap-track-functions Uses feature(s): eval , source , zle Called by: -zplg-load","title":"-zplg-load-plugin"},{"location":"zplugin.zsh/#-zplg-load-snippet","text":"Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload -zplg-run-task -zplg-service zplugin zplugin-autoload.zsh/-zplg-update-or-status-snippet","title":"-zplg-load-snippet"},{"location":"zplugin.zsh/#-zplg-pack-ice","text":"Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zplugin update ...' Has 3 line(s). Doesn't call other functions. Called by: -zplg-load-snippet -zplg-load zplugin-autoload.zsh/-zplg-compute-ice","title":"-zplg-pack-ice"},{"location":"zplugin.zsh/#-zplg-prepare-home","text":"Creates all directories needed by Zplugin, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX","title":"-zplg-prepare-home"},{"location":"zplugin.zsh/#-zplg-register-plugin","text":"Adds the plugin to ZPLG_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: -zplg-load","title":"-zplg-register-plugin"},{"location":"zplugin.zsh/#zplg-register-z-plugin","text":"Registers the z-plugin inside Zplugin \u2013 i.e. an Zplugin extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zplg-register-z-plugin"},{"location":"zplugin.zsh/#--zplg-reload-and-run","text":"Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls --zplg-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-reload-and-run"},{"location":"zplugin.zsh/#-zplg-run-task","text":"A backend, worker function of -zplg-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZPLGM[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): eval , source , zle , zpty Called by: -zplg-scheduler","title":"-zplg-run-task"},{"location":"zplugin.zsh/#-zplg-scheduler","text":"Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive -zplg-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: -zplg-scheduler |-- add-zsh-hook `-- -zplg-run-task |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet `-- zplugin-autoload.zsh/-zplg-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-scheduler"},{"location":"zplugin.zsh/#-zplg-service","text":"Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: -zplg-service |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir `-- -zplg-load-snippet |-- -zplg-deploy-message |-- -zplg-pack-ice |-- -zplg-wrap-track-functions `-- zplugin-install.zsh/-zplg-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplg-service"},{"location":"zplugin.zsh/#--zplg-shadow-alias","text":"Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: --zplg-shadow-alias `-- -zplg-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-alias"},{"location":"zplugin.zsh/#--zplg-shadow-autoload","text":"Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: --zplg-shadow-autoload `-- -zplg-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-autoload"},{"location":"zplugin.zsh/#--zplg-shadow-bindkey","text":"Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: --zplg-shadow-bindkey |-- is-at-least `-- -zplg-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-bindkey"},{"location":"zplugin.zsh/#--zplg-shadow-compdef","text":"Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: --zplg-shadow-compdef `-- -zplg-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-compdef"},{"location":"zplugin.zsh/#-zplg-shadow-off","text":"Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: -zplg-debug-stop -zplg-load-plugin","title":"-zplg-shadow-off"},{"location":"zplugin.zsh/#-zplg-shadow-on","text":"Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: -zplg-debug-start -zplg-load-plugin","title":"-zplg-shadow-on"},{"location":"zplugin.zsh/#--zplg-shadow-zle","text":"Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: --zplg-shadow-zle `-- -zplg-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-zle"},{"location":"zplugin.zsh/#--zplg-shadow-zstyle","text":"Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: --zplg-shadow-zstyle `-- -zplg-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"--zplg-shadow-zstyle"},{"location":"zplugin.zsh/#-zplg-submit-turbo","text":"If `zplugin load`, `zplugin light` or `zplugin snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that -zplg-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zplugin","title":"-zplg-submit-turbo"},{"location":"zplugin.zsh/#-zplg-unregister-plugin","text":"Removes the plugin from ZPLG_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: -zplg-unregister-plugin `-- -zplg-any-to-user-plugin Called by: zplugin-autoload.zsh/-zplg-unload","title":"-zplg-unregister-plugin"},{"location":"zplugin.zsh/#-zplg-wrap-track-functions","text":"Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: -zplg-load-plugin -zplg-load-snippet","title":"-zplg-wrap-track-functions"},{"location":"zplugin.zsh/#zplugin","text":"Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zplugin |-- compinit |-- -zplg-clear-debug-report | `-- zplugin-autoload.zsh/-zplg-clear-report-for |-- -zplg-compdef-clear |-- -zplg-compdef-replay |-- -zplg-debug-start | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-on |-- -zplg-debug-stop | |-- -zplg-diff | | |-- -zplg-diff-env | | |-- -zplg-diff-functions | | |-- -zplg-diff-options | | `-- -zplg-diff-parameter | `-- -zplg-shadow-off |-- -zplg-debug-unload | `-- zplugin-autoload.zsh/-zplg-unload |-- -zplg-ice |-- -zplg-load | |-- -zplg-any-to-user-plugin | |-- -zplg-deploy-message | |-- -zplg-load-plugin | | |-- -zplg-add-report | | |-- -zplg-diff | | | |-- -zplg-diff-env | | | |-- -zplg-diff-functions | | | |-- -zplg-diff-options | | | `-- -zplg-diff-parameter | | |-- -zplg-diff-env | | |-- -zplg-find-other-matches | | |-- -zplg-shadow-off | | |-- -zplg-shadow-on | | `-- -zplg-wrap-track-functions | |-- -zplg-pack-ice | |-- -zplg-register-plugin | `-- zplugin-install.zsh/-zplg-setup-plugin-dir |-- -zplg-load-snippet | |-- -zplg-deploy-message | |-- -zplg-pack-ice | |-- -zplg-wrap-track-functions | `-- zplugin-install.zsh/-zplg-download-snippet |-- -zplg-submit-turbo |-- zplugin-autoload.zsh/-zplg-cdisable |-- zplugin-autoload.zsh/-zplg-cenable |-- zplugin-autoload.zsh/-zplg-clear-completions |-- zplugin-autoload.zsh/-zplg-compiled |-- zplugin-autoload.zsh/-zplg-compile-uncompile-all |-- zplugin-autoload.zsh/-zplg-compinit |-- zplugin-autoload.zsh/-zplg-help |-- zplugin-autoload.zsh/-zplg-list-bindkeys |-- zplugin-autoload.zsh/-zplg-list-compdef-replay |-- zplugin-autoload.zsh/-zplg-ls |-- zplugin-autoload.zsh/-zplg-module |-- zplugin-autoload.zsh/-zplg-recently |-- zplugin-autoload.zsh/-zplg-search-completions |-- zplugin-autoload.zsh/-zplg-self-update |-- zplugin-autoload.zsh/-zplg-show-all-reports |-- zplugin-autoload.zsh/-zplg-show-completions |-- zplugin-autoload.zsh/-zplg-show-debug-report |-- zplugin-autoload.zsh/-zplg-show-registered-plugins |-- zplugin-autoload.zsh/-zplg-show-report |-- zplugin-autoload.zsh/-zplg-show-times |-- zplugin-autoload.zsh/-zplg-show-zstatus |-- zplugin-autoload.zsh/-zplg-uncompile-plugin |-- zplugin-autoload.zsh/-zplg-uninstall-completions |-- zplugin-autoload.zsh/-zplg-unload |-- zplugin-autoload.zsh/-zplg-update-or-status |-- zplugin-autoload.zsh/-zplg-update-or-status-all |-- zplugin-install.zsh/-zplg-compile-plugin |-- zplugin-install.zsh/-zplg-forget-completion `-- zplugin-install.zsh/-zplg-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zplugin"},{"location":"zplugin.zsh/#-zplugin_scheduler_add_sh","text":"Copies task into ZPLG_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zplugin_scheduler_add_sh"},{"location":"zplugin.zsh/#add-zsh-hook","text":"Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body -zplg-scheduler","title":"add-zsh-hook"},{"location":"zplugin.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zplugin","title":"compinit"},{"location":"zplugin.zsh/#is-at-least","text":"Has 56 line(s). Doesn't call other functions. Called by: Script-Body --zplg-shadow-bindkey","title":"is-at-least"},{"location":"zsh-native-scripting-handbook/","text":"Zsh Native Scripting Handbook # This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts. Information # @ is about keeping array form # How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible. extended_glob # Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh. Constructs # Reading a file # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines. Reading from stdin # This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed. Skipping grep # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use \\#i glob flag ( ...:#(#i)\\*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that. Multi-line matching like with grep # Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | \\grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see this section ). Pattern matching in AND-fashion # [[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match \\*abc* but not ... . Then, ^ is also a negation. The effect is: \\*abc* but not those that don't have \\*efg* which equals to: \\*abc* but those that have also \\*efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[\\(R)\\*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson. Skipping tr # declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment. Ternary expressions with \\+,-,:+,:- substitutions # HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. \\(( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use. Ternary expressions with :# substitution # var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one. Using built-in regular expressions engine # [[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb \\## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution. Skipping uniq # declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array. Skipping awk # declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name. Searching arrays # declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 \\[[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that Skipping grep that uses :# substitution can also be used to search arrays. Code execution in // substitution # append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast. Serializing data # declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" ) Tip: serializing with Bash # array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible. Real world examples # Testing for Git subcommand # Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork. Counting unquoted-only apostrophes # A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ). Tips and Tricks # Parsing INI file # With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#zsh_native_scripting_handbook","text":"This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts.","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#information","text":"","title":"Information"},{"location":"zsh-native-scripting-handbook/#is_about_keeping_array_form","text":"How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible.","title":"@ is about keeping array form"},{"location":"zsh-native-scripting-handbook/#extended_glob","text":"Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh.","title":"extended_glob"},{"location":"zsh-native-scripting-handbook/#constructs","text":"","title":"Constructs"},{"location":"zsh-native-scripting-handbook/#reading_a_file","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines.","title":"Reading a file"},{"location":"zsh-native-scripting-handbook/#reading_from_stdin","text":"This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed.","title":"Reading from stdin"},{"location":"zsh-native-scripting-handbook/#skipping_grep","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use \\#i glob flag ( ...:#(#i)\\*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that.","title":"Skipping grep"},{"location":"zsh-native-scripting-handbook/#multi-line_matching_like_with_grep","text":"Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | \\grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see this section ).","title":"Multi-line matching like with grep"},{"location":"zsh-native-scripting-handbook/#pattern_matching_in_and-fashion","text":"[[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match \\*abc* but not ... . Then, ^ is also a negation. The effect is: \\*abc* but not those that don't have \\*efg* which equals to: \\*abc* but those that have also \\*efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[\\(R)\\*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson.","title":"Pattern matching in AND-fashion"},{"location":"zsh-native-scripting-handbook/#skipping_tr","text":"declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment.","title":"Skipping tr"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_--_substitutions","text":"HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. \\(( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use.","title":"Ternary expressions with \\+,-,:+,:- substitutions"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_substitution","text":"var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one.","title":"Ternary expressions with :# substitution"},{"location":"zsh-native-scripting-handbook/#using_built-in_regular_expressions_engine","text":"[[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb \\## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution.","title":"Using built-in regular expressions engine"},{"location":"zsh-native-scripting-handbook/#skipping_uniq","text":"declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array.","title":"Skipping uniq"},{"location":"zsh-native-scripting-handbook/#skipping_awk","text":"declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name.","title":"Skipping awk"},{"location":"zsh-native-scripting-handbook/#searching_arrays","text":"declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 \\[[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that Skipping grep that uses :# substitution can also be used to search arrays.","title":"Searching arrays"},{"location":"zsh-native-scripting-handbook/#code_execution_in_substitution","text":"append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast.","title":"Code execution in // substitution"},{"location":"zsh-native-scripting-handbook/#serializing_data","text":"declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" )","title":"Serializing data"},{"location":"zsh-native-scripting-handbook/#tip_serializing_with_bash","text":"array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible.","title":"Tip: serializing with Bash"},{"location":"zsh-native-scripting-handbook/#real_world_examples","text":"","title":"Real world examples"},{"location":"zsh-native-scripting-handbook/#testing_for_git_subcommand","text":"Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork.","title":"Testing for Git subcommand"},{"location":"zsh-native-scripting-handbook/#counting_unquoted-only_apostrophes","text":"A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ).","title":"Counting unquoted-only apostrophes"},{"location":"zsh-native-scripting-handbook/#tips_and_tricks","text":"","title":"Tips and Tricks"},{"location":"zsh-native-scripting-handbook/#parsing_ini_file","text":"With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Parsing INI file"},{"location":"zsh-plugin-standard/","text":"Version: 1.0, 11/22/2019 Zsh Plugin Standard # This document defines the Zsh Plugin Standard. Zplugin fully supports this standard. This document is also available as a PDF . What Is A Zsh Plugin? # Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). This is being done either by a plugin manager or by the plugin itself (see 5 th section for more information). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization. 1. Standardized $0 Handling # To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides. The assignment uses quoting to make it resilient to combination of GLOB_SUBST and GLOB_ASSIGN options. It's a standard snippet of code, so it has to be always working. When you'll set e.g.: the zsh emulation in a function, you in general don't have to quote assignments. Adoption Status # Plugin managers: Zplugin, Zgen (after and if the PR will be merged) Plugins: GitHub search 2. Unload Function # If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process. Adoption Status # One plugin manager, Zplugin, implements plugin unloading and calls the function. One plugin, romkatv/powerlevel10k , is Two plugins: romkatv/powerlevel10k , is using the function to execute a specific task: shutdown of the binary, background gitstatus demon, with a very good results, agkozak/agkozak-zsh-prompt , is using the function for the full unload of the theme. 3. @zsh-plugin-run-on-unload Call # The plugin manager can provide a function @zsh-plugin-run-on-unload which has the following call syntax: @zsh-plugin-run-on-unload \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on unload of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, in the current shell. The mechanism thus provides another way, side to the unload function , for the plugin to participate in the process of unloading it. Adoption Status # It's a recent addition to the standard and only one plugin manager, Zplugin, implements it. 4. @zsh-plugin-run-on-update Call # The plugin manager can provide a function @zsh-plugin-run-on-update which has the following call syntax: @zsh-plugin-run-on-update \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on update of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, possibly in a subshell. Adoption Status # It's a recent addition to the standard and only one plugin manager, Zplugin, implements it. 5. Plugin Manager Activity Indicator # Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ ${zsh_loaded_plugins[-1]} != */kalc && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager. The code uses the wrapping braces around variables (i.e.: e.g.: ${fpath\u2026} ) to make it compatible with the KSH_ARRAYS option and the quoting around ${0:h} to make it compatible with the SH_WORD_SPLIT option. Adoption Status # Plugin managers: Zplugin, Zgen (after and if the PR will be merged) Plugins: GitHub search 5. Global Parameter With PREFIX For Make, Configure, Etc. # Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zplugin uses this name and places this directory at ~/.zplugin/polaris by default. User can then configure hooks (feature of e.g. zplug and Zplugin) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zplugin/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zplugin ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\" Adoption Status # One plugin manager, Zplugin, provides the $ZPFX parameter. Zsh Plugin-Programming Best Practices # The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section. Use Of add-zsh-hook To Install Hooks # Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation . Use Of add-zle-hook-widget To Install Zle Hooks # Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead. Standard Recommended Options # The following code snippet is recommended to be included at the beginning of each of the main functions provided by the plugin: emulate -L zsh setopt extended_glob warn_create_global typeset_silent \\ no_short_loops rc_quotes no_auto_pushd It resets all the options to their default state according to the zsh emulation mode, with use of the local_options option \u2013 so the options will be restored to their previous state when leaving the function. It then alters the emulation by 6 different options: extended_glob \u2013 enables one of the main Zshell features \u2013 the advanced, built-in regex-like globing mechanism, warn_create_global \u2013 enables warnings to be printed each time a (global) variable is defined without being explicitly defined by a typeset , local , declare , etc. call; it allows to catch typos and missing localizations of the variables and thus prevents from writing a bad code, typeset_silent \u2013 it allows to call typeset , local , etc. multiple times on the same variable; without it the second call causes the variable contents to be printed first; using this option allows to declare variables inside loops, near the place of their use, which sometimes helps to write a more readable code, no_short_loops \u2013 disables the short-loops syntax; this is done because when the syntax is enabled it limits the parser's ability to detect errors (see this zsh-workers post for the details), rc_quotes \u2013 adds useful ability to insert apostrophes into an apostrophe-quoted string, by use of '' inside it, e.g.: 'a string''s example' will yield the string a string's example , no_auto_pushd - disables the automatic push of the directory passed to cd builtin onto the directory stack; this is useful, because otherwise the internal directory changes done by the plugin will pollute the global directory stack. Standard Recommended Variables # It's good to localize the following variables at the entry of the main function of a plugin: local MATCH REPLY; integer MBEGIN MEND local -a match mbegin mend reply The variables starting with m and M are being used by the substitutions utilizing (#b) and (#m) flags, respectively. They should not leak to the global scope. Also, their automatic creation would trigger the warning from the warn_create_global option. The reply and REPLY parameters are being normally used to return an array or a scalar from a function, respectively \u2013 it's the standard way of passing values from functions. Their use is naturally limited to the functions called from the main function of a plugin \u2013 they should not be used to pass data around e.g.: in between prompts, thus it's natural to localize them in the main function. Standard Function Name-Space Prefixes # The recommendation is purely subjective opinion of the author. It can evolve \u2013 if you have any remarks, don't hesitate to fill them . The Problems Solved By The Proposition # However when adopted, the proposition will solve the following issues: Using the underscore _ to namespace functions \u2013 this isn't the right thing to do because the prefix is being already used by the completion functions, so the namespace is already filled up greatly and the plugin functions get lost in it. Not using a prefix at all \u2013 this is also an unwanted practice as it pollutes the command namespace ( an example of such issue appearing). It would allow to quickly discriminate between function types \u2013 e.g.: seeing the : prefix informs the user that it's a hook-type function, while seeing the @ prefix informs the user that it's an API-like function, etc. It also provides an improvement during programming, by allowing to quickly limit the number of completions offered by the editor, e.g.: for Vim's Ctrl-P completing, when entering +<Ctrl-P> , then only a subset of the functions is being completed (see below for the type of the functions). Note: the editor has to be configured so that it accepts such special characters as part of keywords, for Vim it's: :set isk+=@-@,.,+,/,: for all of the proposed prefixes. The Proposed Function-Name Prefixes # The proposition of the standard prefixes is as follows: . : for regular private functions. Example function: .prompt_zinc_get_value . : : for hook-like functions, so it should be used e.g.: for the Zsh hooks and the Zle hooks , but also for any other custom hook-like mechanism in the plugin (e.g.: Zplugin annexes use such prefix for the Zplugin hook functions). Example function name: :prompt_zinc_precmd . + : for output functions, i.e.: for functions that print to the standard output and error or to a log, etc. Example function name: +prompt_zinc_output_segment . / : for debug functions, i.e: for functions that output debug messages to the screen or to a log or e.g.: gather some debug data. Note: the slash makes it impossible for such functions to be auto-loaded via the autoload mechanism. It is somewhat risky to assume, that this will never be needed for the functions, however the limited number of available ASCII characters justifies such allocation. Example function name: /prompt_zinc_dmsg . @ : for API-like functions, i.e: for functions that are on a boundary to a subsystem and expose its functionality through a well-defined, in general fixed interface. For example this plugin standard defines the function @zsh-plugin-run-on-update , which is exposing a plugin manager's functionality in a well-defined way. Example Code Utilizing The Prefixes # .zinc_register_hooks() { add-zsh-hook precmd :zinc_precmd /zinc_dmsg \"Installed precmd hook with result: $?\" @zsh-plugin-run-on-unload \"add-zsh-hook -d precmd :zinc_precmd\" +zinc_print \"Zinc initialization complete\" } Preventing Function Pollution # When writing a larger autoload function, it very often is the case that the function contains definitions of other functions. When the main function finishes executing, the functions are being left defined. This might be undesired, e.g.: because of the command name-space pollution. The following snippet of code, when added at the beginning of the main function will automatically unset the sub-functions when leaving the main function: # Don't leak any functions typeset -g prjef prjef=( ${(k)functions} ) trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef\" EXIT trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef; return 1\" INT Replace the prj* prefix with your project name, e.g.: rustef for a rust -related plugin. The *ef stands for \"entry functions\". The snippet works as follows: The line prjef=( ${(k)functions} ) remembers all the functions that are currently defined \u2013 which means that the list excludes the functions that are to be yet defined by the body of the main function. The code unset -f -- \"${(k)functions[@]:|prjef}\" first does an subtraction of array contents \u2013 the :| substitution operator \u2013 of the functions that are defined at the moment of leaving of the function (the trap -s invoke the code in this moment) with the list of functions from the start of the main function \u2013 the ones stored in the variables $prjef . It then unsets the resulting list of the functions \u2013 being only the newly defined functions in the main function \u2013 by passing it to unset -f \u2026 . This way the functions defined by the body of the main (most often an autoload) function will be only set during the execution of the function. Preventing Parameter Pollution # When writing a plugin one often needs to keep a state during the Zsh session. To do this it is natural to use global parameters. However, when the number of the parameters grows one might want to limit it. With the following method, only a single global parameter per plugin can be sufficient: typeset -A PLGMAP typeset -A some_map typeset -a some_array # Use PLGMAP[state]=1 some_map[state]=1 some_array[1]=state can be converted into: typeset -A PLGMAP # Use PLGMAP[state]=1 PLGMAP[some_map__state]=1 PLGMAP[some_array__1]=state The use of this method is very unproblematic. The author reduced the number of global parameters in one of projects by 21 by using an automatic conversion with Vim substitution patterns with back references without any problems. Appendix A: Revision History (History Of Updates To The Document) # v1.0, 11/22/2019: Removed quoting from the $0 assignments v0.99, 10/26/2019: Added Adoption Status sub-sections v0.98, 10/25/2019: 1/ Added Standard Recommended Variables section v0.98, 10/25/2019: 2/ Added Standard Function Name-Space Prefixes section v0.98, 10/25/2019: 3/ Added Preventing Function Pollution section v0.98, 10/25/2019: 4/ Added Preventing Parameter Pollution section v0.97, 10/23/2019: Added Standard Recommended Options section v0.96, 10/23/2019: Added @zsh-plugin-run-on-unload and @zsh-plugin-run-on-update calls v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that $ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#zsh_plugin_standard","text":"This document defines the Zsh Plugin Standard. Zplugin fully supports this standard. This document is also available as a PDF .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#what_is_a_zsh_plugin","text":"Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). This is being done either by a plugin manager or by the plugin itself (see 5 th section for more information). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization.","title":"What Is A Zsh Plugin?"},{"location":"zsh-plugin-standard/#146_standardized_0_handling","text":"To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides. The assignment uses quoting to make it resilient to combination of GLOB_SUBST and GLOB_ASSIGN options. It's a standard snippet of code, so it has to be always working. When you'll set e.g.: the zsh emulation in a function, you in general don't have to quote assignments.","title":"1. Standardized $0 Handling"},{"location":"zsh-plugin-standard/#adoption_status","text":"Plugin managers: Zplugin, Zgen (after and if the PR will be merged) Plugins: GitHub search","title":"Adoption Status"},{"location":"zsh-plugin-standard/#246_unload_function","text":"If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process.","title":"2. Unload Function"},{"location":"zsh-plugin-standard/#adoption_status_1","text":"One plugin manager, Zplugin, implements plugin unloading and calls the function. One plugin, romkatv/powerlevel10k , is Two plugins: romkatv/powerlevel10k , is using the function to execute a specific task: shutdown of the binary, background gitstatus demon, with a very good results, agkozak/agkozak-zsh-prompt , is using the function for the full unload of the theme.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#3_zsh-plugin-run-on-unload_call","text":"The plugin manager can provide a function @zsh-plugin-run-on-unload which has the following call syntax: @zsh-plugin-run-on-unload \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on unload of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, in the current shell. The mechanism thus provides another way, side to the unload function , for the plugin to participate in the process of unloading it.","title":"3. @zsh-plugin-run-on-unload Call"},{"location":"zsh-plugin-standard/#adoption_status_2","text":"It's a recent addition to the standard and only one plugin manager, Zplugin, implements it.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#4_zsh-plugin-run-on-update_call","text":"The plugin manager can provide a function @zsh-plugin-run-on-update which has the following call syntax: @zsh-plugin-run-on-update \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on update of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, possibly in a subshell.","title":"4. @zsh-plugin-run-on-update Call"},{"location":"zsh-plugin-standard/#adoption_status_3","text":"It's a recent addition to the standard and only one plugin manager, Zplugin, implements it.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#546_plugin_manager_activity_indicator","text":"Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ ${zsh_loaded_plugins[-1]} != */kalc && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager. The code uses the wrapping braces around variables (i.e.: e.g.: ${fpath\u2026} ) to make it compatible with the KSH_ARRAYS option and the quoting around ${0:h} to make it compatible with the SH_WORD_SPLIT option.","title":"5. Plugin Manager Activity Indicator"},{"location":"zsh-plugin-standard/#adoption_status_4","text":"Plugin managers: Zplugin, Zgen (after and if the PR will be merged) Plugins: GitHub search","title":"Adoption Status"},{"location":"zsh-plugin-standard/#546_global_parameter_with_prefix_for_make_configure_etc","text":"Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zplugin uses this name and places this directory at ~/.zplugin/polaris by default. User can then configure hooks (feature of e.g. zplug and Zplugin) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zplugin/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zplugin ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\"","title":"5. Global Parameter With PREFIX For Make, Configure, Etc."},{"location":"zsh-plugin-standard/#adoption_status_5","text":"One plugin manager, Zplugin, provides the $ZPFX parameter.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#zsh_plugin-programming_best_practices","text":"The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section.","title":"Zsh Plugin-Programming Best Practices"},{"location":"zsh-plugin-standard/#use_of_add-zsh-hook_to_install_hooks","text":"Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation .","title":"Use Of add-zsh-hook To Install Hooks"},{"location":"zsh-plugin-standard/#use_of_add-zle-hook-widget_to_install_zle_hooks","text":"Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead.","title":"Use Of add-zle-hook-widget To Install Zle Hooks"},{"location":"zsh-plugin-standard/#standard_recommended_options","text":"The following code snippet is recommended to be included at the beginning of each of the main functions provided by the plugin: emulate -L zsh setopt extended_glob warn_create_global typeset_silent \\ no_short_loops rc_quotes no_auto_pushd It resets all the options to their default state according to the zsh emulation mode, with use of the local_options option \u2013 so the options will be restored to their previous state when leaving the function. It then alters the emulation by 6 different options: extended_glob \u2013 enables one of the main Zshell features \u2013 the advanced, built-in regex-like globing mechanism, warn_create_global \u2013 enables warnings to be printed each time a (global) variable is defined without being explicitly defined by a typeset , local , declare , etc. call; it allows to catch typos and missing localizations of the variables and thus prevents from writing a bad code, typeset_silent \u2013 it allows to call typeset , local , etc. multiple times on the same variable; without it the second call causes the variable contents to be printed first; using this option allows to declare variables inside loops, near the place of their use, which sometimes helps to write a more readable code, no_short_loops \u2013 disables the short-loops syntax; this is done because when the syntax is enabled it limits the parser's ability to detect errors (see this zsh-workers post for the details), rc_quotes \u2013 adds useful ability to insert apostrophes into an apostrophe-quoted string, by use of '' inside it, e.g.: 'a string''s example' will yield the string a string's example , no_auto_pushd - disables the automatic push of the directory passed to cd builtin onto the directory stack; this is useful, because otherwise the internal directory changes done by the plugin will pollute the global directory stack.","title":"Standard Recommended Options"},{"location":"zsh-plugin-standard/#standard_recommended_variables","text":"It's good to localize the following variables at the entry of the main function of a plugin: local MATCH REPLY; integer MBEGIN MEND local -a match mbegin mend reply The variables starting with m and M are being used by the substitutions utilizing (#b) and (#m) flags, respectively. They should not leak to the global scope. Also, their automatic creation would trigger the warning from the warn_create_global option. The reply and REPLY parameters are being normally used to return an array or a scalar from a function, respectively \u2013 it's the standard way of passing values from functions. Their use is naturally limited to the functions called from the main function of a plugin \u2013 they should not be used to pass data around e.g.: in between prompts, thus it's natural to localize them in the main function.","title":"Standard Recommended Variables"},{"location":"zsh-plugin-standard/#standard_function_name-space_prefixes","text":"The recommendation is purely subjective opinion of the author. It can evolve \u2013 if you have any remarks, don't hesitate to fill them .","title":"Standard Function Name-Space Prefixes"},{"location":"zsh-plugin-standard/#the_problems_solved_by_the_proposition","text":"However when adopted, the proposition will solve the following issues: Using the underscore _ to namespace functions \u2013 this isn't the right thing to do because the prefix is being already used by the completion functions, so the namespace is already filled up greatly and the plugin functions get lost in it. Not using a prefix at all \u2013 this is also an unwanted practice as it pollutes the command namespace ( an example of such issue appearing). It would allow to quickly discriminate between function types \u2013 e.g.: seeing the : prefix informs the user that it's a hook-type function, while seeing the @ prefix informs the user that it's an API-like function, etc. It also provides an improvement during programming, by allowing to quickly limit the number of completions offered by the editor, e.g.: for Vim's Ctrl-P completing, when entering +<Ctrl-P> , then only a subset of the functions is being completed (see below for the type of the functions). Note: the editor has to be configured so that it accepts such special characters as part of keywords, for Vim it's: :set isk+=@-@,.,+,/,: for all of the proposed prefixes.","title":"The Problems Solved By The Proposition"},{"location":"zsh-plugin-standard/#the_proposed_function-name_prefixes","text":"The proposition of the standard prefixes is as follows: . : for regular private functions. Example function: .prompt_zinc_get_value . : : for hook-like functions, so it should be used e.g.: for the Zsh hooks and the Zle hooks , but also for any other custom hook-like mechanism in the plugin (e.g.: Zplugin annexes use such prefix for the Zplugin hook functions). Example function name: :prompt_zinc_precmd . + : for output functions, i.e.: for functions that print to the standard output and error or to a log, etc. Example function name: +prompt_zinc_output_segment . / : for debug functions, i.e: for functions that output debug messages to the screen or to a log or e.g.: gather some debug data. Note: the slash makes it impossible for such functions to be auto-loaded via the autoload mechanism. It is somewhat risky to assume, that this will never be needed for the functions, however the limited number of available ASCII characters justifies such allocation. Example function name: /prompt_zinc_dmsg . @ : for API-like functions, i.e: for functions that are on a boundary to a subsystem and expose its functionality through a well-defined, in general fixed interface. For example this plugin standard defines the function @zsh-plugin-run-on-update , which is exposing a plugin manager's functionality in a well-defined way.","title":"The Proposed Function-Name Prefixes"},{"location":"zsh-plugin-standard/#example_code_utilizing_the_prefixes","text":".zinc_register_hooks() { add-zsh-hook precmd :zinc_precmd /zinc_dmsg \"Installed precmd hook with result: $?\" @zsh-plugin-run-on-unload \"add-zsh-hook -d precmd :zinc_precmd\" +zinc_print \"Zinc initialization complete\" }","title":"Example Code Utilizing The Prefixes"},{"location":"zsh-plugin-standard/#preventing_function_pollution","text":"When writing a larger autoload function, it very often is the case that the function contains definitions of other functions. When the main function finishes executing, the functions are being left defined. This might be undesired, e.g.: because of the command name-space pollution. The following snippet of code, when added at the beginning of the main function will automatically unset the sub-functions when leaving the main function: # Don't leak any functions typeset -g prjef prjef=( ${(k)functions} ) trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef\" EXIT trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef; return 1\" INT Replace the prj* prefix with your project name, e.g.: rustef for a rust -related plugin. The *ef stands for \"entry functions\". The snippet works as follows: The line prjef=( ${(k)functions} ) remembers all the functions that are currently defined \u2013 which means that the list excludes the functions that are to be yet defined by the body of the main function. The code unset -f -- \"${(k)functions[@]:|prjef}\" first does an subtraction of array contents \u2013 the :| substitution operator \u2013 of the functions that are defined at the moment of leaving of the function (the trap -s invoke the code in this moment) with the list of functions from the start of the main function \u2013 the ones stored in the variables $prjef . It then unsets the resulting list of the functions \u2013 being only the newly defined functions in the main function \u2013 by passing it to unset -f \u2026 . This way the functions defined by the body of the main (most often an autoload) function will be only set during the execution of the function.","title":"Preventing Function Pollution"},{"location":"zsh-plugin-standard/#preventing_parameter_pollution","text":"When writing a plugin one often needs to keep a state during the Zsh session. To do this it is natural to use global parameters. However, when the number of the parameters grows one might want to limit it. With the following method, only a single global parameter per plugin can be sufficient: typeset -A PLGMAP typeset -A some_map typeset -a some_array # Use PLGMAP[state]=1 some_map[state]=1 some_array[1]=state can be converted into: typeset -A PLGMAP # Use PLGMAP[state]=1 PLGMAP[some_map__state]=1 PLGMAP[some_array__1]=state The use of this method is very unproblematic. The author reduced the number of global parameters in one of projects by 21 by using an automatic conversion with Vim substitution patterns with back references without any problems.","title":"Preventing Parameter Pollution"},{"location":"zsh-plugin-standard/#appendix_a_revision_history_history_of_updates_to_the_document","text":"v1.0, 11/22/2019: Removed quoting from the $0 assignments v0.99, 10/26/2019: Added Adoption Status sub-sections v0.98, 10/25/2019: 1/ Added Standard Recommended Variables section v0.98, 10/25/2019: 2/ Added Standard Function Name-Space Prefixes section v0.98, 10/25/2019: 3/ Added Preventing Function Pollution section v0.98, 10/25/2019: 4/ Added Preventing Parameter Pollution section v0.97, 10/23/2019: Added Standard Recommended Options section v0.96, 10/23/2019: Added @zsh-plugin-run-on-unload and @zsh-plugin-run-on-update calls v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that $ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Appendix A: Revision History (History Of Updates To The Document)"}]}